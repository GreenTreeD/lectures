2 РК и зачёт(автоматом можно, если оба рк написаны нормально), лабораторные работы(проводит Берчун)
РК разбиты на 2 этапа: практическая задача(20 минут) и предлагается теория при успешном выполнении практической задачи.

# Лекция №1. Синтез комбинационных схем, логические основы цифровых автоматов.
При проектировании цифровых систем в качестве математического аппарата применяется булева алгебра/алгебра логики, где в качестве переменных используются логические переменные. 
В общей сложности логическая схема представляется в виде "чёрного ящика", которых имеет *n* входов ($x_1, x_2 ... x_n$ ) и *m* выходов ($y_1, y_2 ... y_m$). При схемной реализации переменные $x_1, x_2 ... x_n$ являются входными сигналами, а значения сигналов $y_1, y_2 ... y_m$ - выходными. Заметим, что входные и выходные сигналы могут иметь различную физическую природу, но принимают только 2 значения (0 или 1).
Цель булевой алгебры - описание поведения и структуры логической схемы. Чтобы описать поведение логической схемы, нужно выразить каждый выход как логическую функцию от входных переменных: $$y_j = f(x_1, x_2, ... x_n)\qquad \forall j = 1...m$$. Логическая функция  может быть задана как таблично,(с помощью таблицы истинности) таки аналитически(при помощи булевых выражений). Булево выражение представляет собой формулу, состоящую из булевых переменных и констант, связанных булевыми операциями. 

## Основные логические функции цифровой схемотехники
Все функции реализуются на базе нижеперечисленных логических функций:
1. Конъюкнция, операция "И", логическое умножение.
	Функция равна нулю тогда, когда хотя бы один из аргументов равен нулю.
	$y = x_1 \cdot x_2$, обозначается знаком "&" на схемах, имеет *n* входов и один выход.
	
![[Pasted image 20250224110012.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 1   |
2. Дизъюнкция, логическое сложение, операция "ИЛИ"
	Функция равна единице, если хотя бы один из аргументов равен единице. 
	$y = x_1 + x_2$, обозначается знаком "1" на схемах, имеет *n* входов и один выход.

![[Pasted image 20250224110000.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 1   |
3. Инверсия, операция "НЕ", логическое отрицание.
	Функция одной переменной. Инвертирует значение функции.
	$y = \overline{x}$. 
	![[Pasted image 20250224105934.png]]

| $x_1$ | y   |
| ----- | --- |
| 0     | 1   |
4. Операция Шеккера (И - НЕ), коньюнкиция с инверсией результата
	Функция равна  нулю тогда, когда все аргументы равны единице.
	$y = \overline{x_1 \cdot x_2}$
	
	![[Pasted image 20250224110041.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 0   |
5. Стрелка Пирса, операция ИЛИ-НЕ, XOR
	Функция равна 0, когда хотя бы один из элементов равен 1.
	$y = \overline{x_1 + x_2}$
	
	![[Pasted image 20250224105905.png]]
	
| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 0   |

6. Сложение по модулю 2, исключающее ИЛИ
	Функция определена только для 2 элементов.
	$y=x_1\oplus x_2$ ИЛИ $y=\overline{x_1}\cdot x_2 + x_1\cdot \overline{x_2}$ 
	
	![[Pasted image 20250224105834.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 0   |
7. Сложение по модулю 2 с инверсией
	$y=\overline{x_1\oplus x_2}$ ИЛИ $y=\overline{x_1}\cdot \overline{x_2} + x_1\cdot x_2$ 

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 1   |


Основное понятие - понятие функциональной полноты булевой функции. 
*Опр.* Система булевых функций называется **функционально полной**, если на её основе можно получить любую булеву функцию, используя лишь операцию суперпозиций.
Набор функций "И", "ИЛИ", "НЕ" является функционально полной системой.
Набор функций "И-НЕ" тоже является функционально полной системой.
Набор функций "ИЛИ-НЕ" тоже является функционально полной системой.

Принцип суперпозиций понимается как подстановка одних булевых функций в качестве аргументов других булевых функций. 
$$ y_1 = x_2 + x_3$$
$$f = x_1 \cdot y = x_1 \cdot (x_1 + x_2) $$

## Основные законы булевой алгебры

1. Двойное отрицание - значение самой переменной. $$\overline{\overline{x}} = x$$
2. Коммутативность
3. Дистрибутивность
4. Ассоциативность
5. Распределительный закон
6.  $x + 0 = x$
	$x+ 1 = 1$
	$x \cdot 0 = 0$
	$x \cdot 1 = x$
	$x \cdot x = x$
	$x \cdot \overline{x} = 0$
	$x + \overline{x} = 0$
7. Законы Де-Моргана
	$\overline{x_1 \cdot x_2} = \overline{x_1} + \overline{x_2}$
	$\overline{x_1 + x_2} = \overline{x_1} \cdot \overline{x_2}$
	$x_1 \cdot x_2 = \overline{\overline{x_1} + \overline{x_2}}$
	$x_1 + x_2 = \overline{\overline{x_1} \cdot \overline{x_2}}$
8. Закон склеивания и поглощения
	$x_1\cdot(x_1+x_2) = x_1$
	$x_1 + x_1 \cdot x_2 = x_1$
	$x_1 + \overline{x_1}\cdot x_2 = x_1 + x_2$
	$x_1 \cdot (\overline{x_1} + x_2) = x_1 \cdot x_2$


С помощью таблиц истинности удобно описывать поведение логической схемы, а с помощью аналитического выражение - структуру. 

## Нормальная форма булевых функций

Возьмём произвольную функцию $f(x_1, x_2, x_3) = (x_1 + \overline{x_2})\cdot(\overline{x_1}+x_3) + x_2\cdot x_3$
В алгебре логики выделяют ряд форм, которые называются нормальными формами, т.е. подразумевается, что у функций может быть несколько аналитических представлений, но нормальная форма одна.
1. ДНФ. Сумма произведений
	Минтерм - конъюнктивный терм, который содержит все переменные функции. 1 - наименьший конъюнктивный терм.
	СДНФ -  Совершенная дизъюнктивная нормальная форма - ДНФ, состоящая только из минтермов. 
2. КНФ. Произведение сумм
	Макстерм - дизъюнктивный терм, который содержит все переменные функции.  0 - наименьший дизъюнктивный терм. 
	СКНФ -  Совершенная конъюнктивная нормальная форма - КНФ, состоящая только из макстермов.

СДНФ и СКНФ у булевой функции могут быть только одни. 

## Получение совершенных форм по таблице истинности

1. Задана функция $y = f(a,b,c)$ с помощью таблицы истинности

| a   | b   | c   | y   |
| --- | --- | --- | --- |
| 0   | 0   | 0   | 0   |
| 0   | 0   | 1   | 0   |
| 0   | 1   | 0   | 0   |
| 0   | 1   | 1   | 1   |
| 1   | 0   | 0   | 0   |
| 1   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   |
| 1   | 1   | 1   | 1   |
Как получить СДНФ:
1. Выбираются строки, где функция равна 1
2. Каждой такой строке соответствует терм, переменная входит без отрицания, если значение переменной равно 1; с отрицанием, если значение переменной равно 0.
3. Полученные термы записываются через "+"
$$y = \overline{a}\cdot b \cdot d + a \cdot b \cdot \overline{c} + a \cdot b \cdot c$$

Как получить СКНФ:
1. Выбираются строки, где функция равна 0
2. Каждой такой строке соответствует терм, переменная входит без отрицания, если значение переменной равно 0,с отрицанием, если значение переменной равно 0.
3. Полученные термы записываются через умножение. 
$$ y = (a+b+c)\cdot(a+b+\overline{c})\cdot(a+\overline{b}+c)\cdot(\overline{a}+b+c)\cdot(\overline{a}+\overline{b}+c)$$
Ну и соответственно можно обратно по форме построить схему....

В аналитическом выражении операции выполняются по приоритету: отрицание, умножение, сложение, сложение по модулю два.

# Лекция №2. 
*К предыдущей лекции, а то забыли.* Существуют два основных класса логических схем.

*Опр.* Логическая схема, которую можно полностью описать таблицами истинности  или булевыми выражениями, называется __комбинационной схемой__. (КС)
Особенность таких схем является: значение выходных сигналов полностью определяются значениями входных сигналов в текущий момент времени. 

*Опр.* __Последовательстные схемы__ или схемы с внутренней памятью - схемы, где значения выходных сигналов определяются не только текущими значениями входных сигналов, но и их значениями в предыдущие моменты времени. 

## Минимизация логических функций
Сложность логических функций, а так же сложность реализующей её логической схемы, прямопорциональны числу операций и числу переменных. (см пример выше) Поэтому при проектировании логических схем выполняют *минимизацию* логических функций.

*Опр*. Минимизацией логических функций называют нахождение наиболее простого её представления с минимальным количеством символов(операций и переменных). 

Рассмотрим два способа минимизации функций. 

### Преобразование аналитического выражения
$$y = \overline{a}bc + ab\overline{c} + abc = \overline{a}bc + ab(\overline{c}+c) = \overline{a}bc + ab = b\cdot(a+\overline{a}c) = b\cdot(a+c) = ab + bc$$

Построим схему по полученному выражению:
/тут две картинки должны быть/

Рассмотрим ещё один пример:
$$y = x_1\cdot x_2 + x_2\cdot x_3 + \overline{x_1}\cdot x_3$$
Представим $x_2\cdot x_3\cdot 1$ как $x_2\cdot x_3 (x_1 + \overline{x_1})$:
$$y = x_1\cdot x_2 + x_1\cdot x_2\cdot x_3 + \overline{x_1}\cdot x_2\cdot x_3 + \overline{x_1}\cdot x_3 = x_1\cdot x_2 (1+ x_3) + \overline{x_1}\cdot x_3(1+x_2) = x-1 \cdot x_2 + \overline{x_1} \cdot x_3$$

Почему это неудобно? Этот способ не является алгоритмическим, поэтому не очень понятно, когда стоит применять такой способ

### Карты Карно
А это уже алгоритмический способ, так что сидим радуемся жизни. 
Для расширения кругозора: карты Карно ещё называются диаграммами Вейче.

Карты Карно это графическое двухмерное представление таблицы истинности. Значения в карте Карно записываются как по горизонтали, так и по вертикали. Переменные функции делят пополам: если количество переменных чётно, то записывают пополам, если нечётно, то по горизонтали или вертикали, то где-то на одну больше. 
Порядок размещения различных комбинаций значений переменных выбирается в коде Грея, т.е. наборы значений соседних клеток различаются одним разрядом. 

#### Получение кода Грея


#### Непосредственно карты Карно

Таблица исходной функции:

| a   | b   | f   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   |

Составим карту Карно с переменной b по горизонтали и переменной а по вертикали:

| ...   | 0   | 1   |
| ----- | --- | --- |
| __0__ | 0   | 0   |
| __1__ | 0   | 1   |

Составим карту Карно для 3 переменных:

| ...   | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| __0__ |     |     |     |     |
| __1__ |     |     |     |     |

Аналогично для 4 и более переменных 

## Получение минимальной ДНФ по картам Карно

1. Заполняются ячейки карты Карно по таблице истинности для функции.
2. На карте Карно выделяются прямоугольные контуры по следующим правилам:
	1. Контуры могут содержать только 1.
	2. Количество клеток внутри контура может быть равно только степени 2. ($2^0$, $2^1$ и др.... т.е. в контуре может быть 1, 2, 4 и тд клеток)
	3. Контуры могут пересекаться.
	4. Сами контуры, т.е. их размер, должны быть как можно больше. 
	5. Количество контуров должно быть как можно меньше.
	6. Следует учитывать, что верхняя строка и нижняя строка карты Карно являются соседними, а так же левый и правый столбцы тоже являются соседними. 
3. Получение МДНФ: каждому выделенному контуру соответствуют терм ака конъюнкция переменных. Причём в терм входят только те переменные, которые не меняют своего значения в пределах контура. Переменная входит без отрицания, если она равна 1 в пределах контура, или с отрицанием, если она равна 0 в пределах контура. 
4. Полученные термы объединяются в функции дизъюнкции. 

Пример на нашем любимом примере)))))))))))).
Функция для минимизации: $y = \overline{a}bc + ab\overline{c} + abc$

Карта Карно(a по вертикали и bc по горизонтали):

| ...   | 00  | 01  | 11            | 10      |
| ----- | --- | --- | ------------- | ------- |
| __0__ |     |     | 1(1 к.)       |         |
| __1__ |     |     | 1(1 к.)(2 к.) | 1(2 к.) |

Первый контур: $bc$ 
Второй контур: $ab$ 

Объединяем: $y = ab + bc$
Получили ту же самую форму, которую получили преобразованием.

#### Ыщо примеры на выделение контуров

##### Пример №1
ab по вертикали и cd по горизонтали

| ...    | 00      | 01   | 11   | 10   |
| ------ | ------- | ---- | ---- | ---- |
| __00__ | 1(2)    |      | 1(3) | 1(3) |
| __01__ | 1(2)    |      | 1(3) | 1(3) |
| __11__ | 1(1)(2) | 1(1) |      |      |
| __10__ | 1(2)    |      |      |      |
(Колво клеток тока по степеням двойки!!!!!!)

Первый контур: $\overline{c}\overline{d}$
Второй контур: $ab\overline{c}$
Третий контур: $\overline{a}c$

МДНФ: $f = ab\overline{c}+\overline{c}\overline{d}+\overline{a}c$

##### Пример №2
ab по вертикали и cd по горизонтали

| ...    | 00   | 01  | 11   | 10   |
| ------ | ---- | --- | ---- | ---- |
| __00__ |      |     | 1(2) |      |
| __01__ | 1(1) |     |      | 1(1) |
| __11__ | 1(1) |     |      | 1(1) |
| __10__ |      |     | 1(2) |      |
(Препод дальтоник, рисуем контуры овальчиками)

Первый контур: $b\overline{d}$
Второй контур: $\overline{b}cd$

МДНФ: $f = b\overline{d}+ \overline{b}cd$

##### Пример №3
ab по вертикали и cd по горизонтали

| ...    | 00  | 01  | 11  | 10  |
| ------ | --- | --- | --- | --- |
| __00__ | 1   |     |     | 1   |
| __01__ |     |     |     |     |
| __11__ |     |     |     |     |
| __10__ | 1   |     |     | 1   |
Ставьте лайк если тоже нашли один контур

МДНФ: $f = \overline{b}\overline{d}$

### Синтез полного одноразрядного сумматора
В базисе "И", "ИЛИ", "НЕ"
/картинка/
$S = f(A, B, P_0)$
$P_1 = \phi(A,B,P_0)$
??????

| $P_0$ | A   | B   | S   | $P_1$ |
| ----- | --- | --- | --- | ----- |
| 0     | 0   | 0   | 0   | 0     |
| 0     | 0   | 1   | 1   | 0     |
| 0     | 1   | 0   | 1   | 0     |
| 0     | 1   | 1   | 0   | 1     |
| 1     | 0   | 0   | 1   | 0     |
| 1     | 0   | 1   | 0   | 1     |
| 1     | 1   | 0   | 0   | 1     |
| 1     | 1   | 1   | 1   | 1     |

Карта Карно:

| ...   | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| __0__ |     | 1   |     | 1   |
| __1__ | 1   |     | 1   |     |

А как минимизировать..... никак.

$S = \overline{P_0}\cdot \overline{A}B + P_0\cdot \overline{A}\overline{B} + P_2\cdot A\cdot B + \overline{P_0}A\overline{B}$
$P_1 = A\cdot B + P_0 \cdot B + P_0 \cdot A$

Схема:
//картинка//

Требование с Госта: входы слева, выходы справа, линии только горизонтальные и вертикальные


# Лекция №3
Полный одноразрядный сумматор: надо сложить два одноразрядных числа по модулю два. Учитывается перенос остатка.
Схема:
![[Pasted image 20250224103421.png]]

$$S = \overline{A}\cdot \overline{B}\cdot P_0 + \overline{A} \cdot B \cdot \overline{P_0} + A\cdot B \cdot P_0 + A \cdot \overline{B}\cdot \overline{P_0} = P_0(\overline{A}\cdot \overline{B}+A\cdot B)+\overline{P_0}(\overline{A}\cdot B + A \cdot \overline{B})$$
$$S=P_0(\overline{A\oplus B})+\overline{P}(A\oplus B) = P_0 \oplus(A \oplus B)$$
Для $P_1$:
$$P_1 = A\cdot B + P_0 \cdot A + P_0 \cdot B=A\cdot B + P_0(A+B) = A\cdot B + P_0 (A\oplus B)$$
## Задача №1
Синтезировать схему в базисе "И", "ИЛИ", "НЕ" по функции, заданной картой Карно

| .... | 00  | 01  | 11  | 10  |
| ---- | --- | --- | --- | --- |
| 00   | 1   | 1   | 1   | 1   |
| 01   | 1   | 1   |     |     |
| 11   | 1   |     | 1   |     |
| 10   | 1   | 1   |     | 1   |

Контуры:
![[Pasted image 20250224103050.png]]

ДНС:
$$f=\overline{a}\cdot\overline{b} + \overline{b} \cdot \overline{d} + \overline{a}\cdot \overline{c} + \overline{c} \cdot \overline{d} + \overline{b} \cdot \overline{c} + a\cdot b \cdot c \cdot d $$

Схема:
/картинка/


## Получение МКНФ по картам Карно
Правило:
1. Выделяют контуры с нулями по тем же правилам, что и для ДНФ.
2. По этим контурам строится мднф для инверсного значения функции, т.е. $\overline{f}$
3. Берём инверсию слева и справа получаем мкнф для самой функции $f$.

Пример:

| .... | 00  | 01  | 11  | 10  |
| ---- | --- | --- | --- | --- |
| 00   | 1   | 1   | 0   | 1   |
| 01   | 0   | 0   | 0   | 0   |
| 11   | 0   | 0   | 0   | 1   |
| 10   | 1   | 1   | 0   | 1   |

Контуры:
![[Pasted image 20250224104534.png]]

Запишем МКНФ:
$$\overline{f} = c\cdot d + \overline{a} \cdot b + b \cdot \overline{c}$$
$$ \overline{\overline{f}} = \overline{c\cdot d + \overline{a} \cdot b + b \cdot \overline{c}}$$
$$ f = \overline{c \cdot d}+ $$

## Неопределённые условия
При проектировании логических схем возможна некоторая комбинация на входе, которая не может появиться или запрещена. В таблице истинности такая строка отсутствует, а в карте Карно ставят символ, отличный от "0" или "1".
При выделении контуров эту клетку можно считать как за "0", так и за "1". Интерпретируем в сторону нашей выходы, т.е. в сторону минимизации количества контуров.

Пример:

| .... | 00  | 01  | 11  | 10  |
| ---- | --- | --- | --- | --- |
| 00   | 0   | -   | 0   | 1   |
| 01   | -   | 1   | 0   | 1   |
| 11   | 0   | 0   | -   | 1   |
| 10   | 0   | 0   | 0   | -   |

Контуры:

![[Pasted image 20250224105550.png]]

МДНФ:
$$f = c\overline{d} +\overline{a}b\overline{c}$$


## Реализация функции на базисе И-НЕ, ИЛИ-НЕ

мумуму мимимими напишите пожалуйста



## Триггерные схемы

Относится к классу последовательностных схем. 
*Опр*. Триггер - устройство с двумя устойчивыми состояниями. 

## Обобщённая структурная схема триггера
![[Pasted image 20250224112925.png]]
ЗЯ - Запоминающая ячейка, СУ - Схема управления, $x_1, x_2 ... x_n$ - информационные сигналы триггера, $c_1, c_2 ... c_n$ - входы синхронизации. 
У триггера всегда два выхода.
Состояние триггера определяется значениями его выходов. 
	Состояние "0": $Q= 0$ , $\overline{Q} = 1$
	Состояние "1": $Q= 1$ , $\overline{Q} = 0$
Cхема управления преобразует входные сигналы и сигналы обратной связи в сигналы S' и R'. S' устанавливает ЗЯ в "1", R' устанавливает в состояние "0".
Запоминающая ячейка сама по себе представляет простейший триггер.

## Классификация триггеров

По функциональному признаку:
1. RS
2. JK
3. D
4. DV(E)
5. T
Возможны комбинированные триггеры.

По способу записи информации:
1. Асинхронные
2. Синхронные

По числу входов синхронизации:
1. Однотактные
2. Многотактные

По организации синхронизирующего входа:
1. Статическое управление записью (происходит по уровню сигнала)
2. Динамическое управление записью (по фронту сигнала, по переднему или по заднему)

По способу передачи входной информации на выход:
1. Одноступенчатые
2. Двухступенчатые

## Основные параметры триггеров

### Схемотехнические
1. Коэффициент объединение по входам (макс. число входов)
2. Коэффициент разветвтления по выходу
3. Напряжение допустимое по мете
4. Входные и выходные напряжение и токи логических "0" и "1"
5. Потребляемая мощность

### Динамические параметры
1. Минимальная длительность входного импульса
	$$t_и = \sum_{i=1}^{i = m}t^* \cdot i$$
	$m$ - колво лог. элементов в цепи от входа(информационного или синхросигнала) до входа логического элемента, на котором замыкается кольцо обратной связи.
2. Разрешающее время триггера или синхросигнала
	Минимально допустимый временной интервал между двумя последовательными импульсами минимальной длительности. 

# Лекция № 4
 Триггерры применяются в счётчиках, регистрах, а так же в памяти если нужно хранить значение нескольких битах, в накапливающих сумматоров, генераторов одиночных импульсов, формирователей сигналов. Используются там где нужно выполнять функции хранения информации.
 
 ## Логическое описание работы триггеров
 Правило Функционирования триггеров могут быть заданы с помощью:
	 Словестное описание
	 Лог функций
	 Таблицы переходов - не путать с таблицой истинности
	 Графов - в котором вершина сотвествует  внутренее состояние тригера, а ребрам управляющий сигнал.
	 В форме микропрограммного автомата
При описание работы триггерра рассматривают два соседних моментов дискретного времени. t_n+2, t_n+1, t_n

Для асинхронных триггероов момент времени t_n+1, когда под действием входных сигналов и взависимости внутренного состояния момента t_n, Триггер переходит в последующее состояние.
Для синхронного сигнала tn и t_n+1 время до и после прихода синхро сигнала соотвествено.

Схемки .......

## Асинхронный RS-триггер (простейший триггер)
С входами R установки в ноль и S установки в 1. используется как запоминающаю ячейку. 

| Время t_n | Время t_n | Время t_n | Время t_n+1 |                                                |
| --------- | --------- | --------- | ----------- | ---------------------------------------------- |
| $R_n$     | $S_n$     | $Q_n$     | $Q_n$       |                                                |
| 0         | 0         | 0         | 0           | $R_n$=$S_n$=0 Режим хранения                   |
| 0         | 0         | 1         | 1           | $R_n$=$S_n$=0, РЕЖИМ ХРАНЕНИЯ $Q_{n+1} = $Q_n$ |
| 0         | 1         | 0         | 1           | Режим переключения в 1                         |
| 0         | 1         | 1         | 1           | Режим переключения 1                           |
| 1         | 0         | 0         | 0           | Режим сброса или переключения в 0              |
| 1         | 0         | 1         | 0           | Режим сброса или переключения в 0              |
| 1         | 1         | 0         | x           | Запрещённая комбинация                         |
| 1         | 1         | 1         | x           | Запрещённые комбинации                         |
$Q_{n+1}=f(R_n,S_n,Q_n)-?$
$Q_{n+1}=\varphi(R_n,S_n,Q_n)-?$

Через карты Карно получим выражения для триггерра RS
$Q_{n+1}=S_n+\bar{R_n}Q_n$(1)
$\bar Q_{n+1}=R_n+\bar{S_n}\bar Q_n$(2)

Для реализации в базисе "и или не" преобразуем формулы 1,2
Из (1): $$\bar Q_{n+1}=\overline{S_n+\bar R_nQ_n}=\overline{S_n+\overline{R_n\bar Q_n}}$$
Из (2): $$Q_{n+1}=\overline{R_n+\overline{S_n+Q_n}}$$
Cхема триггера

Приято рисовать

Упрощённый вариант

Анализируем работу схемы
Много раз нарисовать ячейку с разными состояниями
	1. $R=S=0$ 
		1. $Q=0;\bar Q=1$ (единица на выходе устанавливает 1, если все сигналы нулю равны) Ноль с ЛС1  выхода попадает на вход ЛС2 потверждает 1 состояния входа $\bar Q = 1$ так как  $S=0$. С другой стороны выход ЛС2 потверждает выход $Q=0$, так как $R=0$.
		2.$Q=1;\bar Q = 0$ Единица с ЛС1  выхода попадает на вход ЛС2 потверждает состояния входа $\bar Q =01$ так как  $S=0$. С другой стороны выход ЛС2 потверждает выход $Q=1$, так как $R=0$.
	2. $R=1;S=0$
		1. $Q=0;\bar Q=1$. $R=1$ даже действуя многократно будет, только подтверждать нулевое сотояние выхода ЛС1 и будет подтверждать состояния выхода ЛС2, так как $S=0$.
		2. $Q=1;\bar Q = 0$ переключит состояние в сотояние выхода ЛС1 1->0  и переключит состояния выхода ЛС2 в 1, так как $S=0$, выход ЛС2 потвердит состояние $Q=0$.
	3. $R=0;S=1$
		1. $Q=0;\bar Q=1$. $S= 0$ переключит состояние в сотояние выхода ЛС2 1->0  и переключит состояния выхода ЛС1 в 1, так как $R=0$, выход ЛС1 потвердит состояние $Q=0$..
		2. $Q=1;\bar Q = 0$  Ничего не изменится система не поменятеся.
Отметим Случай 2.1 И 3.2 триггер сохраняет своё прежнее состояние при многократном действие сигнала R или S - называется свойством блокировки, которое и делает RS-триггер запоминающей ячейкой.
	 $R=S=1$ Схема перестаёт быть триггером и считается двумя отдельными ЛC(Kjubxtcrfz c[tvf]). $Q=\bar Q -???$.  Что будет если мы "одновременно снимем". Мы не знаем в каком состояние окажется триггер. Такая же проблема во всех компьютерах при включение его неизвестно в каком состояние будет триггер. Поэтому компы после включения делают инициализацию.
Чтобы переключить триггер в базисе "или не" нужно подать единичные сигналы. Такой триггер называется триггер с прямыми входами.В таком триггере активные уровни сигнал будут единицы.
Если реализовать в бизисе "и не" то будет триггер с инверсными входами. В таком триггере активные уровни сигнал будут нули.
(1): $$Q_{n+1}=\overline{\overline{S_n+\bar R_n*Q_n}}=\overline{\bar S_n *\overline{\bar R_n * Q_n}}$$(2): $$Q_{n+1}=\overline{\overline{R_n+\bar S_n*\bar Q_n}}=\overline{\bar R_n *\overline{\bar S_n * \bar Q_n}}$$

| $\bar S$ | $\bar R$ |            |
| -------- | -------- | ---------- |
| 1        | 1        | хранение   |
| 0        | 1        | уст 1      |
| 1        | 0        | уст 0      |
| 0        | 0        | запрещенна |

Проиллюстрируем работу триггера( временная диаграмма)

# Лекция №5. Состязание(гонки) в асинхронных схемах
Логические функции описывают схему идеализированно, так как они не учитывают задержки в элементах. Наличие задержек в элементах приводит к появлению "гонок" в сигналах. 
Рассмотрим пример.
Есть вот такая схема, по которой мы всегда будем получать на выходе единицу. 
![[Pasted image 20250310101636.png]]

Построим временные диаграммы с учётом задержек на логических элементах:
![[Pasted image 20250310101843.png]]

Отсюда видно, что во время переключения возникает *ложный сигнал* или *помеха*. 
Причины помех:
1. Разное количество логических элементов от входа сигнала до выхода
2. Разные задержки на разных логических элементах

*Опр*. Возможность появления помехи в результате гонок сигналов называют **статическим риском сбоя**.
Для исключения таких сбоев вводят **стробирование**. 

*Опр*. Под **стробированием** понимают выделение из информационного сигнала части, свободной от ложных сигналов. 

*Опр*. Процесс стробирования периодическими сигналами называют **синхронизацией**. 
*Опр*. **Такт** - период следования синхросигнала. 

Синхронизация это частный случай стробирования.

Как правило, всякая комбинационная цепь заканчивается триггером, поэтому стробирование вводят на входах триггерных схем. 

*Опр*. Триггеры, информационные входные сигналы которых стробируются специальными периодическими  импульсами, называются **синхронными триггерами**.

На ряду с защитой от "состязаний" введение синхронизации создаёт условия для одновременного изменения состояния многих триггеров, так называемая *синхронная работа*.

## Синхронные триггеры

Синхронные триггеры имеют один или несколько входов синхронизации. Сигнал синхронизации разрешает приём в триггер сигналов с информационных входов. 
Входы синхронизации обозначают буквой *С*. 
При *С* = 1 вход разрешён, при *С* = 0 вход запрещён. 
Если вход инверсный, то наоборот. 

### Синхронный RS триггер
Как у асинхронного RS триггера есть входы S и R, а ещё есть синхронизирующий вход С. 
Таблица переходов для синхронного RS триггера:

| $C_n$ | $R_n$ | $S_n$ | $Q_n$ | $Q_{n+1}$ |
| ----- | ----- | ----- | ----- | --------- |
| 0     | 0     | 0     | 0     | 0         |
| 0     | 0     | 0     | 1     | 1         |
| 0     | 0     | 1     | 0     | 0         |
| 0     | 0     | 1     | 1     | 1         |
| 0     | 1     | 0     | 0     | 0         |
| 0     | 1     | 0     | 1     | 1         |
| 0     | 1     | 1     | 0     | 0         |
| 0     | 1     | 1     | 1     | 1         |
| 1     | 0     | 0     | 0     | 0         |
| 1     | 0     | 0     | 1     | 1         |
| 1     | 0     | 1     | 0     | 1         |
| 1     | 0     | 1     | 1     | 1         |
| 1     | 1     | 0     | 0     | 0         |
| 1     | 1     | 0     | 1     | 0         |
| 1     | 1     | 1     | 0     | x         |
| 1     | 1     | 1     | 1     | x         |

Целевая функция: $Q_{n+1} = f(C_n, S_n, R_n, Q_n)$ - ?
При *С* = 0, $Q_{n+1} = Q_n$
При $C = 1$, 
Первые две строки - режим хранения
Установка в 1
Установка в 0
Запрещённые комбинации

Карта Карно для функции, по горизонтали $C_n, R_n$:

| --  | 00  | 01  | 11  | 10  |
| --- | --- | --- | --- | --- |
| 00  |     |     |     |     |
| 01  | 1   | 1   |     | 1   |
| 11  | 1   | 1   | x   | 1   |
| 10  |     |     | x   | 1   |

$$Q_{n+1} = \overline{C_n}\cdot Q_n+ C_n\cdot S_n + \overline{R_n}\cdot Q_n$$
Но это неудобно, поэтому преобразуем, чтобы было удобнее реализовать в базисе И-НЕ:
$$ Q_{n+1} = Q_n (\overline{C_n} + \overline{R_n}) + C_n \cdot S_n = C_n\cdot S_n + \overline{C_n \cdot R_n}\cdot Q_n$$ (1)

Аналогично, но самостоятельно, получаем $\overline{Q_{n+1}} = C_n\cdot R_n + \overline{C_n \cdot S_n} \cdot \overline{Q_n}$ (2).

Возьмём  двойную инверсию (1): $Q_{n+1} = \overline{\overline{C_n \cdot S_n}\cdot \overline{\overline{C_n \cdot R_n}\cdot Q_n}}$
(2): $\overline{Q_{n+1}} = \overline{\overline{C_n \cdot R_n}\cdot \overline{\overline{C_n \cdot S_n}\cdot \overline{Q_n}}}$

Из этих двух выражений получим схему:
![[Pasted image 20250310104910.png]]

Условное изображение триггера:
![[photo_2025-03-10_10-48-43.jpg]]


Проиллюстрируем работу триггера с помощью временных диаграмм и оценим работу триггера:
![[Pasted image 20250310110722.png]]

$$t_и \ge3 t^* _{зд. р. ср.}$$
$$t_р \ge 4 t^* _{зд. р. ср.}$$
$$t_{max} = \frac{1}{t_р} = \frac{1}{4 t^* _{зд. р. ср.}}$$

Раз реализовали в И-НЕ, реализуем в ИЛИ-НЕ:
![[Pasted image 20250310110816.png]]
Получили триггер с инверсными входами. 

### Синхронный D триггер
**Асинхронных D триггеров не бывает**
Таблица переходов:

| $C_n$ | $D_n$ | $Q_n$ | $Q_{n+1}$ | $S^*$ | $R^*$ |
| ----- | ----- | ----- | --------- | ----- | ----- |
| 0     | 0     | 0     | 0         | 1     | x     |
| 0     | 0     | 1     | 1         | x     | 1     |
| 0     | 1     | 0     | 0         | 1     | x     |
| 0     | 1     | 1     | 1         | x     | 1     |
| 1     | 0     | 0     | 0         | 1     | x     |
| 1     | 0     | 1     | 0         | 1     | 0     |
| 1     | 1     | 0     | 1         | 0     | 1     |
| 1     | 1     | 1     | 1         | x     | 1     |

При $C=0$, $Q_{n+1} = Q_n$

 Карта Карно:

| ---   | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| **0** |     |     | 1   |     |
| **1** | 1   | 1   | 1   |     |
$$Q_{n+1} = \overline{C_n}\cdot Q_n + C_n \cdot D_n$$

При $C_n = 1$ получаем просто повторитель сигнала. $Q_{n+1} = D_n$, который не обладает памятью.
Будем строить схему ну основе запоминающей ячейки в базисе И-НЕ:


| $Q_n \rightarrow Q_{n+1}$ | $S^*$ | $R^*$ |
| ------------------------- | ----- | ----- |
| 0 -> 0                    | 1     | x     |
| 0 -> 1                    | 0     | 1     |
| 1 -> 0                    | 1     | 0     |
| 1 -> 1                    | x     | 1     |
=>
$S^* = f(C_n, D_n)$ и $R^* = f(C_n, D_n)$

Карта Карно для $S^*$:

| $Q_n$ \\ $C_n, D_n$ | 00  | 01  | 11  | 10  |
| ------------------- | --- | --- | --- | --- |
| **0**               | 1   | 1   |     | 1   |
| **1**               | x   | x   | x   | 1   |

$$S^* = \overline{C_n}+\overline{D_n} = \overline{C_n \cdot D_n}$$
Карта Карно для $R^*$:

| $Q_n$ \\ $C_n, D_n$ | 00  | 01  | 11  | 10  |
| ------------------- | --- | --- | --- | --- |
| **0**               | x   | x   | 1   | x   |
| **1**               | 1   | 1   | 1   |     |
$$R^* = \overline{C_n} + D_n = \overline{\overline{D_n}\cdot C_n}$$
Чтобы обойтись без инвертера преобразуем ф-цию.
$$R^* = \overline{C_n} + D_n = \overline{C_n}+D_n(C_n + \overline{C_n}) = D_n \cdot \overline{C_n} + \overline{C_n} = D_n\cdot C_n + \overline{C_n}(D_n+1) = D_n \cdot C_n + \overline{C_n}$$
$$R^* = \overline{S^*} + \overline{C_n} = \overline{S^* \cdot C_n}$$


Схема:
![[Pasted image 20250310113855.png]]
# Лекция №6
	На следующей паре РК, всё что было в лекции, может быть на РК . Ыгыгыгы)))
	Тема: Синтез комбинационных схем.
	Теории в следующий раз не будет.

## Асинхронный T-триггер
Счётный триггер, так как он умный и умеет считать до двух.
Асинхронный Т триггер функционирует в соответствии со следующей таблице. Имеет один счётный вход, текущее состояние зависит от предыдущего.

| $T_n$ | $Q_n$ | $Q_{n+1}$ | $R'$ | $S'$ |
| ----- | ----- | --------- | ---- | ---- |
| 0     | 0     | 0         | х    | 0    |
| 0     | 1     | 1         | 0    | х    |
| 1     | 0     | 1         | 0    | 1    |
| 1     | 1     | 0         | 1    | 0    |
$Q_{n+1} = f(T_n, Q_n)$
Каждым входным сигналом триггер переключается в следующее состояние.
Строим ДНС:
$Q_{n+1} = \overline{T_n}\cdot Q_n + T_n \cdot \overline{Q_n} = T_n \oplus Q_n$
Нет свойства памяти => строим счётный триггер на основе запоминающей ячейки. Выберем запоминающую ячейку с прямыми входами, тогда сигналы, обеспечивающие переходы, будут следующими:
$R' =T_n \cdot Q_n$ и $S' = T_n \cdot \overline{Q_n}$
Для реализации в базисе И-НЕ возьмём инверсию справа и слева:
$\overline{R'} =\overline{T_n \cdot Q_n}$ и $\overline{S'} = \overline{T_n \cdot \overline{Q_n}}$

Получим следующую схему:
![[Pasted image 20250317102716.png]]

Построим временные диаграммы, чтобы оценить работу схемы:


Когда приходит подтверждение единицы по обратной связи, надо снимать сигнал. Если длительность входного сигнала дольше, чем переходные процессы в триггере, то там возникают колебания и получается генератор, т.е. при действии входного сигнала T триггер многократно переключается между 1 и 0 многократно
$t_и = 2 t^*_{зд.р.ср}$. Генерация возникает, если длина импульса будет больше $2 t^*_{зд.р.ср}$, соответственно длина импульса Т должна быть строго $2 t^*_{зд.р.ср}$, меньше нельзя, так как не успеют сработать элементы 3 и 4. Жёстко стабилизировать время импульса практически невозможно. При изменении внешних условий такая схема будет работать неустойчиво. Поэтому такую схему не используют хд

## Синхронные триггеры с двухступенчатым упоминанием информации и со статическим управлением....

Для построения триггеров типа T- и JK- необходимо, чтобы изменения выходных сигналов было с задержкой, равной длительности входного сигнала. Аналогичная задача возникает, когда необходимо передавать информацию с выхода на вход другого/последующего триггера с помощью одного и того же синхросигнала, например, при построении регистров и счётчиков. 
Для решения этих проблем счётные и JK-триггеры строятся как двухступенчатые или триггеры с динамическим управлением. Пока будем говорить про двухступенчатые с динамическим управлением записью.

В двухступенчатых триггерах имеются две ступени запоминания информации.
1. Основной триггер
2. Вспомогательный триггер
В англоязычной литературе это MS-триггеры. (Master-Slave)

С = 1 - информация записывается в первую ступень, во вторую передача информации запрещена
С = 0 - информация переписывается из первой ступени во вторую, приём информации в первую ступень запрещена. 

Управляющая связь между основным и вспомогательным триггерами может осуществляться следующими способами:
1. С инвертером синхросигнала (запрещающим инвертером)
2. С запрещающими связями
3. С разнополярным управлением
И куча всего разного

### Двуступенчатый RS триггер с запрещающим инвертером

![[Pasted image 20250317112359.png]]

1,2,3,4 - первая ступень, 5,6,7,8 - вторая ступень

К ячейкам 3,4,7,8 подключаем входы  $S_a$ и $R_a$.(см RS триггер)
Эти входы будут инверсными

Динамические параметры данной схемы:
Мин время синхроимпульса: $t_и = 3t*_{зд.р.ср.}$
Разрешающее время синхросигнала: $t = 7t^*$

Если к логическим элементов добавить по сходу, т.е. соединив $\overline{Q}$ со входом элемента 2, а $Q$ с 1, то получится JK триггер. S станет J, а R станет K.

## Синхронные двуступенчатые триггеры с запрещающими связями

### Синхронный двуступенчатый JK триггер

В JK триггере вход J соответствует входу S в RS триггера(установка в 1), K - R(установка в 0).
Отличие от JK триггера от RS триггера заключается в том, что у него нет запрещающей комбинации на входе

S=R=C=1 -> запрещающий
J=K=C=1 -> переключение

Всё остальное как у RS

Нарисуем схему в базисе И-НЕ:
(у второй ступени два синхровхода)
![[Pasted image 20250317112659.png]]

Условная схема:
![[photo_2025-03-17_11-29-08.jpg]]
При С=1 и любом сочетании J и К (кроме J=K=0), состояние нуля будет либо на элементе 1, либо на элементе 2. Этот 0 переключит запоминающую ячейку первой ступени в соответствующее состояние(1 в 1, 2 в 0). Одновременно этот 0 попадает на 5 и 6, запрещая запись на вторую ступень. 
При С=0 на выходах логических элементов 1 и 2 единички, поэтому единица поступает на 5 и 6, разрешая запись с первой ступени на вторую.

Динамические параметры те же самые.

JK триггер называют универсальным триггером, так как его можно использовать в качестве RS, D и T триггера. 
Если входы J и K соединить через инвертер, то будет D триггер
Если J и K соединить и подавать единицу, то при каждом синхроимпульсе будет переключаться в следующее состояние, вход С станет входом Т, получится асинхронный счётный триггер.
Если объединить входы J и K, то они образуют синхронный счёт вход, получится синхронный счётный триггер. 

# Лекция №7
## Синхронный двухступенчатый триггер с запрещающими связями

![[Pasted image 20250324105839.png]]

Условное обозначение:


Двуступенчатый D триггер можно использовать в качестве счётного триггерая

# Лекция №7
## Синхронный D-триггер с динамическим управлением записью
Схема состоит из 3 триггерных схем.
5 и 6 - основной триггер
1, 2 и 3,4 - вспомогательные, осуществляют после управления

![[Pasted image 20250331113825.png]]
$C = 0 -> Q_2 = Q_3 = 1$ - режим хранения для ячейки
$Q_4 = \overline{Q_3\cdot D \cdot R^*_a}= \overline{D}$; $Q_1 = \overline{S^*_a\cdot Q_4 \cdot Q_2} = \overline{Q_4} = D$
Из-за этого один из вспомогательнвх триггеров будет в неправильном состоянии.
При $C=1$ это состояние исчезает.

$C = 1$: 
a)$D = 0$ => $Q_4 = 1$ ; => $Q_3 = 0$ => $Q = 0$ и $\overline{Q} = 1$
0 c выхода логического элемента 3 попадает на логический элемент 4 и блокирует его. $Q_3 = 0$ => $Q_4 = 1$, поэтому никакие ихменения на информационном входе D не повлияют на его состояние, а значит и всей схемы в целом.
При с=1 триггер переключается 1 раз и никакие изменения не повлияют на его состояние.
б)$D = 1$=> $Q_1 = 1$ => $Q_2 = 0$ => $Q = 1$; $\overline{Q} = 0$
$Q_2 = 0$ => $Q_1 = 1$ и $Q_3 = 1$- блокирует элементы 1 и 3. 

Временные диаграммы.
![[Pasted image 20250331113710.png]]

# Лекция
Объявление: необходимым условием зачёта является конспект лекций (пупупу пипипи) в рукописном виде. 

## Асинхронный счётик с параллельным переносом
Идея параллельного переноса: одновременно послать во все разряды через соответствующие управляющие цепи с минимальной задержкой. Перенос в текущий разряд надо генерировать, если все предыдущие разряды равны единице при наличии счётного индекса.
Перенос P1 из первого разряда будет возникать при наличии счётного импульса и при том, что этот разряд равен 1. 
$P_1 = B_x \cdot Q_1$
Перенос из второго в третий разряд
$P_2 = B_x \cdot Q_2 \cdot Q_1$
$P_3 = B_x \cdot Q_3 \cdot Q_2 \cdot Q_1$
...
$P_n = B_x \cdot Q_n \cdot Q_{n-1} ... \cdot Q_2 \cdot Q_1$

Схема четырёхразрядного счётчика на двуступенчатых счётных триггерах:

При поступлении счётного сигнала на вход всех конъюнкторы переключатся одновременно, а следственно переключатся одновременно все разряды счётчиков.
$t_{уст.} = t_{зд.р.ср.}^и +t_{зд.р.}^{T_2(II)}$
$T \geq t_и + t_{уст.} = t_{зд.р.}^{T_2(I)}+t_{зд.р}^{и}+t_{зд.р}^{T_2(II)}$

## Счётчики с групповым переносом
В тех случаях, когда ограничение на коэффициент объединения по входу схем И и коэффициент разветвеления по выходу триггеров не позволяют строить схему с параллельным переносом, счётчик разбивают на группы разрядов. Внутри группы используется параллельный перенос, а между группам последовательный перенос или сквозной. 

Асинхронный счётчик с параллельным переносом и синхронные счётчики являются самыми быстродействующими.

## Синхронные счётчики
При построении синхронных счётчиков счётный сигнал поступает одновременно на синхровход всех триггеров. 
Идея сквозного переноса и параллельного переноса точно такие же, как и в асинхронных счётчиках. (Но есть нюанс.)
В асинхронных счётчиках степень пересчёта была равна степени двойки.

## Синтез синхронных счётчиков с параллельным переносом с произвольным модулем счёта
Широкое распространение получили счётчики с модулем счёта m=10.


Синтезировать суммирующий счётчик по модулю 10 на JK триггерах.

Алгоритм синтеза синхронных счётчиков (на примере):
1. При построении синхронных счётчиков сигнал подаётся одновременно на синхровходы всех триггеров.
2. Определение разрядов счётчика. $n = I\cdot \log_2 M [$
	\[ - округление до целого числа справа.
	Пример: $n =I\log_2 10[ = ] 3.32... [ = 4$
	Можно решать методом подбора)))))))))))))))))))
3. Выбор типа триггеров
	Обычно счётчики строятся либо на JK, либо на D триггеров. 
4. Составляется таблица переходов для выбранного типа триггеров

| $Q^t -> Q^{t+1}$ | J        | K        | D   |
| ---------------- | -------- | -------- | --- |
| 0 -> 0           | 0        | $\alpha$ | 0   |
| 0 -> 1           | 1        | $\alpha$ | 1   |
| 1 -> 0           | $\alpha$ | 1        | 0   |
| 1 -> 1           | $\alpha$ | 0        | 1   |

5. Когда разобрались с таблицей переходов выбранного триггера, составляем таблицу переходов для всего счётчика. 

| N   | $Q_4^t->Q_4^{t+1}$ | $Q_3^t->Q_3^{t+1}$ | $Q_2^t->Q_2^{t+1}$ | $Q_1^t->Q_1^{t+1}$ | $J_4$    | $K_4$    | $J_3$    | $K_3$    | $J_2$    | $K_2$    | $J_1$    | $K_1$    |
| --- | ------------------ | ------------------ | ------------------ | ------------------ | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 1   | 0->0               | 0->0               | 0->0               | 0->1               | 0        | $\alpha$ | 0        | $\alpha$ | 0        | $\alpha$ | 1        | $\alpha$ |
| 2   | 0->0               | 0->0               | 0->1               | 1->0               | 0        | $\alpha$ | 0        | $\alpha$ | 1        | $\alpha$ | $\alpha$ | 1        |
| 3   | 0->0               | 0->0               | 1->1               | 0->1               | 0        | $\alpha$ | 0        | $\alpha$ | $\alpha$ | 0        | 1        | $\alpha$ |
| 4   | 0->0               | 0->1               | 1->0               | 1->0               | 0        | $\alpha$ | 1        | $\alpha$ | $\alpha$ | 1        | $\alpha$ | 1        |
| 5   | 0->0               | 1->1               | 0->0               | 0->1               | 0        | $\alpha$ | $\alpha$ | 0        | 0        | $\alpha$ | 1        | $\alpha$ |
| 6   | 0->0               | 1->1               | 0->1               | 1->0               | 0        | $\alpha$ | $\alpha$ | 0        | 1        | $\alpha$ | $\alpha$ | 1        |
| 7   | 0->0               | 1->1               | 1->1               | 0->1               | 0        | $\alpha$ | $\alpha$ | 0        | $\alpha$ | 0        | 1        | $\alpha$ |
| 8   | 0->1               | 1->0               | 1->0               | 1->0               | 1        | $\alpha$ | $\alpha$ | 1        | $\alpha$ | 1        | $\alpha$ | 1        |
| 9   | 1->1               | 0->0               | 0->0               | 0->1               | $\alpha$ | 0        | 0        | $\alpha$ | 0        | $\alpha$ | 1        | $\alpha$ |
| 10  | 1->0               | 0->0               | 0->0               | 1->0               | $\alpha$ | 1        | 0        | $\alpha$ | 0        | $\alpha$ | $\alpha$ | 1        |
N - номер перехода
6. Таблица позволяет определить функции для управляющих сигналов входов J и K всех триггеров. $J_i^t = f_i(Q_1,Q_2,Q_3,Q_4)^t$ и $K_j = \phi_j(Q_1,Q_2,Q_3,Q_4)^t$

$J_1$:

| $Q_2 Q_1$ \ $Q_4 Q_3$ | 00       | 01       | 11  | 10       |
| --------------------- | -------- | -------- | --- | -------- |
| 0 0                   | 1        | 1        |     | 1        |
| 01                    | $\alpha$ | $\alpha$ |     | $\alpha$ |
| 11                    | $\alpha$ | $\alpha$ |     |          |
| 10                    | 1        | 1        |     |          |
Пустые клетки - запрещённые состояния.
$J_1 = 1$

$K_1$:

| $Q_2 Q_1$ \ $Q_4 Q_3$ | 00       | 01       | 11  | 10       |
| --------------------- | -------- | -------- | --- | -------- |
| 0 0                   | $\alpha$ | $\alpha$ |     | $\alpha$ |
| 01                    | 1        | 1        |     | 1        |
| 11                    | 1        | 1        |     |          |
| 10                    | $\alpha$ | $\alpha$ |     |          |
$K_1 = 1$


$J_2$:

| $Q_2 Q_1$ \ $Q_4 Q_3$ | 00       | 01       | 11  | 10  |
| --------------------- | -------- | -------- | --- | --- |
| 00                    | 0        | 0        |     | 0   |
| 01                    | 1        | 1        |     | 0   |
| 11                    | $\alpha$ | $\alpha$ |     |     |
| 10                    | $\alpha$ | $\alpha$ |     |     |
$J_2 = Q_1 \cdot \overline{Q_1}$


$K_2$:

| $Q_2 Q_1$ \ $Q_4 Q_3$ | 00       | 01       | 11  | 10       |
| --------------------- | -------- | -------- | --- | -------- |
| 00                    | $\alpha$ | $\alpha$ |     | $\alpha$ |
| 01                    | $\alpha$ | $\alpha$ |     | $\alpha$ |
| 11                    | 1        | 1        |     |          |
| 10                    | 0        | 0        |     |          |
$K_2 = Q_1$
$J_3 = K_3 = Q_2 \cdot Q_1$
$J_4 = Q_3 \cdot Q_2 \cdot Q_1$
$K_4 = Q_1$

7. Нарисовать схему


# Лекция №9
Если нужно построить вычитающий счётчик, то логика будет такая же, но будут другие переходы. 

## Реверсивные счётчики
Все счётчики, которые рассматривали, были суммирующими в том или ином плане. Вычитающие - если присоединять к инверсным входам.
Реверсивные счётчики выполняют как и операцию сложения, так и операцию вычитания. 
$cr := cr + 1$ и $cr := cr - 1$
Эти режимы реализуются под воздействием управляющего сигнала или при смене точки подачи входных сигналов. 
В первом случае схема имеет счётный и управляющий входы
Во втором случае счётчик имеет два входа: суммирующий и вычитающий

Наиболее распространённый способ построения реверсивных счётчиков - переключение межразрядных связей. 

## Асинхронный двоичный реверсивный счётчик
Схема:
![[Pasted image 20250421103709.png]]

Для того, чтобы счётчик работал в режиме вычитания, ко входу следующего триггера надо подключить инверсный сигнал предыдущего. В зависимости от режима надо переключать сигнал с прямого на инверсивный, т.е. поставить коммутатор между триггерами для переключения сигналов. 

Можно реализовать это с помощью "2И-ИЛИ"
Схема:
![[Pasted image 20250421103751.png]]

Эквивалетная схема:
![[Pasted image 20250421103659.png]]
Но чаще всего реализуется как один логический элемент
Реализуемая функция: $y = x_1 \cdot x_2 + x_3 \cdot x_4$
Пусть $x_2 =1$; $x_4 = 0$ => $y = x_1$
Пусть $x_2 = 0$; $x_4 = 1$ => $y = x_3$
Считая $x_2$ и $x_4$ управляющими сигналами, можем передавать информацию со входа $x_1$ или $x_3$.

## Реализация схемы асинхронного реверсивного счётчика с параллельным переносом на JK триггерах
Схема:
![[Pasted image 20250421103513.png]]

При СЛ = ВЧ = 0: ничего не будет.... режим хранения.
При СЛ=1, ВЧ = 0: по верхним конъюнкторам коммутаторов на его выходе будет прямое значение предыдущего разряда, т.е. сложение 
При СЛ = 0, ВЧ = 1: режим вычитания
При СЛ = ВЧ = 1: эточё)))) на коммутаторах будет 1. Первая ступень триггера переключится в противоположное состояние. Будет $\overline{Q_{i+1}}^{(I)}$
	Если после этого будет СЛ = ВЧ = 0, то $T_{i+1}$ = 0, $Q_{i+1}^{(II)} = \overline{Q_{n+1}}$
	Все разряды инвертируются, а значит это запрещённая комбинация. 

Временная диаграмма счётчика в режиме вычитания: СЛ = 0 ВЧ = 1

Q3 - старший, Q1 - младший.
![[Pasted image 20250421105617.png]]
## Регистры
*Опр.* Регистр - RG - функциональный узел, предназначенный для ввода, хранения, преобразования и вывода двоичного слова или его части. Узел накапливающего типа. 
В самом простом случае представляет из себя набор триггеров, но есть нюанс.
Регистр состоит из триггеров и управляющих логических элементов. 

Регистры выполняют ряд микроопераций над словами, которые можно разделить на 4 группы:
1. Приём слова (установка в нулевое или единичное состояние, приём слова в прямом или обратном коде)
2. Выдача слова в прямом или обратном коде
3. Выполнение поразрядных логических операций
4. Сдвиг слов влево или вправо на то или иное число разрядов, преобразование последовательного кода в параллельный или обратно

### Классификация регистров

По способу ввода и вывода информации:
1. Параллельные (регистры памяти)
	Ввод и вывод слова происходит одновременно по всем разрядам. Каждый разряд подаётся по своей цепи.
2. Последовательные (регистры сдвига)
	Разряды слова передаются последовательно во времени. Один разряд за другим при входе, так и при выходе. 
3. Параллельно-последовательные
	Могут выполнять взаимные преобразования последовательного кода в параллельный и обратно.

По способу представления информации на входе и выходе:
1. Парафазные
	Код каждого разряда передаётся своими прямым $D_i$ и инверсным $\overline{D_i}$ значениями. Т.е. нужны две линии для передачи кода разряда.
2. Однофазные
	Передаётся либо только прямое $D_i$ или инверсное $\overline{D_i}$ значение, т.е. нужна одна линия связи.

### Параллельные регистры
Число триггеров в регистре равно числу разрядов в регистре. 

Схема: параллельный регистр на асинхронных RS триггерах.

Условное графическое обозначение:
![[Pasted image 20250421112029.png]]

ПЧ - сигнал приёма числа
X = $x_1, x_2, x_3$ -код числа

Режимы работы:
1. ПЧ = 0, уст0 = 1 => $Q_i = 0$
2. уст0 = 0, П4 = 1 => $Q_i = x_i$

Особенностью этой схемы является то, что мы все разряды должны установить в 0. 
В этой схеме записываются только единички. 

$t_{зд. р. ср}^{RG} = t_{сброс}^{T_2}+t_{зд. р. ср}^{И}+t_{зд. р. ср}^{T_2}$

### Парафазный регистр
Схема:

Здесь не требуется изначальная установка регистра в 0
$t_{зд. р. ср}^{RG} = t_{зд. р. ср}^{T_2}$

### Параллельный регистр на D триггерах


# Лекция
TODO: перекинуть из-под винды


# Лекция от 05.05
Пусть $x = x_1 x_2... x_n$ - слово, поступающее на вход дешифратора, где $x_1$ - старший разряд, а $x_n$ - младший разряд. $y = y_0 y_1 .... y_{m-1}$ - слово, которое формируется на выходе дешифратора ($m=2^n$), то работа дешифратора описывается следующей булевой функцией.
$$y_ 0 = \overline{x_1}\cdot \overline{x_2} ... \overline{x_{n-2}}\cdot \overline{x_{n-1}}\cdot \overline{x_n}$$

$$$$
$$...\xspace ... ...$$
(1)

$$\begin{aligned} 
y_ 0 = \overline{x_1}\cdot \overline{x_2} ... \overline{x_{n-2}}\cdot \overline{x_{n-1}}\cdot \overline{x_n} \\
y_ 1 = \overline{x_1}\cdot \overline{x_2} ... \overline{x_{n-2}}\cdot \overline{x_{n-1}}\cdot x_n \\
y_ 2 = \overline{x_1}\cdot \overline{x_2} ... \overline{x_{n-2}}\cdot x_{n-1}\cdot \overline{x_n} \\
y_ 3 = \overline{x_1}\cdot \overline{x_2} ... \overline{x_{n-2}}\cdot x_{n-1}\cdot x_n \\
... ... ...

\end{aligned}$$
То есть отрицания снимаются по двоичному коду.

## Основные параметры дешифратора
1. Число выходов - $n$, число входов - $k$.
2. Входные, выходные токи и напряжения в логических нулях и единицах, $U_{доп.}^{помех.}$ - статические параметры
3. Динамические параметры: $t_{здр.}^{DC}$  (0/1 и 1/0)

Существует три основных способа построения дешифраторов: 
1. Линейный
2. Пирамидальный
3. Ступенчатый

## Линейные дешифраторы

Строится непосредственно в соответствии системы функций (1), состоит из $2^n$ конъюнкторов с $m$ входами каждый.

| Входы |       | Выходы |       |       |       |
| ----- | ----- | ------ | ----- | ----- | ----- |
| $x_2$ | $x_1$ | $y_0$  | $y_1$ | $y_2$ | $y_3$ |
| 0     | 0     | 1      |       |       |       |
| 0     | 1     |        | 1     |       |       |
| 1     | 0     |        |       | 1     |       |
| 1     | 1     |        |       |       | 1     |

$$\begin{aligned}
y_0 = \overline{x_2}\cdot \overline{x_1} \\
y_1 = \overline{x_2}\cdot x_1 \\
y_3 = x_2 \cdot x_1
\end{aligned}$$
Схема:
<>
<>
В схеме присутствуют гонки сигналов (прямой сигнал и сигнал через инвертер). Способ борьбы с ними - стробирование по последнему каскаду. Для этого на элементы И следует добавить дополнительные входы, их объединить, получится стробирующий вход $EC$(или $CE$).

(Почти все дешифраторы делаются со стробирующим входом.)

В данном дешифраторе ... единица, на остальных выходах действует сигнал нуля. Такой дешифратор называется дешифратором с **прямыми выходами**. Условное графическое обозначение:
<>
При построении дешифратора на элементах И-НЕ получится дешифратор с **инверсными выходами**.

Достоинство схемы - самый быстрый дешифатор.
$t_{зд. р. ср.}^{DC} = t_{зд.р.ср.}^{НЕ}+t_{зд.р.ср.}^{И}$

Недостаток схемы - кол-во входов ограничено сверху коэффициентом объединения по входу.

## Пирамидальный дешифратор

Принцип его построения следующий: $y = x_1 \cdot x_2 \cdot x_3 \cdot x_4 = ((x_1\cdot x_2)\cdot x_3)\cdot x_4$ . Каскадно короче. 
Достоинство: простые элементы с двумя входами
Недостаток: $t_{зд.р.ср.}^{DC} = t^{НЕ}_{зд.р.ср.}+(n-1)\cdot t^{И}_{зд.р.ср.}$
Так что такие дешифраторы уже почти не используются....

## Ступенчатые дешифраторы

$y = x_1 \cdot x_2 \cdot x_3 \cdot x_4 = ((x_1 \cdot x_2)\cdot(x_3 \cdot x_4))$
В ступенчатых дешифраторах *n* входов разбиваются по $\frac{n}{2}$ переменных в каждой группе. (если *n* - чётно....). Ели *n* нечётно, то на $\frac{n+1}{2}$ и $\frac{n-1}{2}$ .
Для каждой такой группы строится линейный дешифратор. Затем по матричной схемы с помощью элемента И на два входа, каждый выход одного дешифратора объединяется с каждым выходом другого и таким образом и таким образом получается вторая ступень дешифрации.
Короче, задачу большей размерности сводим к задаче меньшей размерности.
При большом количестве входов *n* ступенчатые дешифраторы имеют существеено меньшие аппаратные затраты, чем линейные и пирамидальные. 

## Объединение/наращивание дешифраторов

Обычно дешифраторы строятся стробируемыми, стробирующий сигнал должен действовать после переходных процессов в дешифраторе. Так же стробирующий вход дешифраторов используется для наращивания дешифраторов 
Часто схема дешифратора содержит не один, а несколько входов стробирования, которые внутри схемы объединяются логической функцией (чаще всего умножения).

### Построить 4-х разрядных дешифратор на основе 3-х разрядного

<картинка>
$x_4 = 0$ => запрет работы DC2, отрабатывает DC1.
$x = 0 x_3 x_2 x_1$
выдаются сигналы $y_0 ... y_7$

$x_4 = 1$ => запрет работы DC1, отрабатывает DC2.
$x = 1 x_3 x_2 x_1$
выдаются сигналы $y_8 ... y_15$

## Дешифраторы двоично-десятичных входов

Это пример неполного дешифратора.
Кол-во входов - 4, кол-во выходов - 9
$$\begin{aligned}
y_0 = \overline{x_1}\cdot\overline{x_2} \cdot \overline{x_3}
\cdot \overline{x_4} \\
y_1 = \overline{x_1}\cdot\overline{x_2} \cdot \overline{x_3}
\cdot x_4 \\
... .... .... ... ..... \\
y_9 = x_1 \cdot \overline{x_2} \cdot \overline{x_3} \cdot x_4 
\end{aligned}$$
6 входных наборов не используется, а значит этим наборам можно поставить в соответствие любое значение выходов для упрощения схемы дешифратора.

Объясни это с помощью карты карно

| $x_2 x_1$\ $x_4 x_3$ | 00  | 01  | 11  | 10  |
| -------------------- | --- | --- | --- | --- |
| 00                   |     |     | x   |     |
| 01                   |     |     | x   |     |
| 11                   |     |     | x   | x   |
| 10                   |     |     | x   | x   |
Не минимизируются $y_0$ и $y_1$ до двуходовых и трёхходовых.


## Шифраторы

Обратная функция от дешифратора. 


