Преподаватель: Шестаков Сергей Александрович
2 РК и зачёт(автоматом можно, если оба рк написаны нормально), лабораторные работы(проводит Берчун)
РК разбиты на 2 этапа: практическая задача(20 минут) и предлагается теория при успешном выполнении практической задачи.

# Лекция №1. Синтез комбинационных схем, логические основы цифровых автоматов.
При проектировании цифровых систем в качестве математического аппарата применяется булева алгебра/алгебра логики, где в качестве переменных используются логические переменные. 
В общей сложности логическая схема представляется в виде "чёрного ящика", которых имеет *n* входов ($x_1, x_2 ... x_n$ ) и *m* выходов ($y_1, y_2 ... y_m$). При схемной реализации переменные $x_1, x_2 ... x_n$ являются входными сигналами, а значения сигналов $y_1, y_2 ... y_m$ - выходными. Заметим, что входные и выходные сигналы могут иметь различную физическую природу, но принимают только 2 значения (0 или 1).
Цель булевой алгебры - описание поведения и структуры логической схемы. Чтобы описать поведение логической схемы, нужно выразить каждый выход как логическую функцию от входных переменных: $$y_j = f(x_1, x_2, ... x_n)\qquad \forall j = 1...m$$. Логическая функция  может быть задана как таблично,(с помощью таблицы истинности) таки аналитически(при помощи булевых выражений). Булево выражение представляет собой формулу, состоящую из булевых переменных и констант, связанных булевыми операциями. 

## Основные логические функции цифровой схемотехники
Все функции реализуются на базе нижеперечисленных логических функций:
1. Конъюкнция, операция "И", логическое умножение.
	Функция равна нулю тогда, когда хотя бы один из аргументов равен нулю.
	$y = x_1 \cdot x_2$, обозначается знаком "&" на схемах, имеет *n* входов и один выход.
	
![[Pasted image 20250224110012.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 1   |
2. Дизъюнкция, логическое сложение, операция "ИЛИ"
	Функция равна единице, если хотя бы один из аргументов равен единице. 
	$y = x_1 + x_2$, обозначается знаком "1" на схемах, имеет *n* входов и один выход.

![[Pasted image 20250224110000.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 1   |
3. Инверсия, операция "НЕ", логическое отрицание.
	Функция одной переменной. Инвертирует значение функции.
	$y = \overline{x}$. 
	![[Pasted image 20250224105934.png]]

| $x_1$ | y   |
| ----- | --- |
| 0     | 1   |
4. Операция Шеккера (И - НЕ), коньюнкиция с инверсией результата
	Функция равна  нулю тогда, когда все аргументы равны единице.
	$y = \overline{x_1 \cdot x_2}$
	
	![[Pasted image 20250224110041.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 0   |
5. Стрелка Пирса, операция ИЛИ-НЕ, XOR
	Функция равна 0, когда хотя бы один из элементов равен 1.
	$y = \overline{x_1 + x_2}$
	
	![[Pasted image 20250224105905.png]]
	
| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 0   |

6. Сложение по модулю 2, исключающее ИЛИ
	Функция определена только для 2 элементов.
	$y=x_1\oplus x_2$ ИЛИ $y=\overline{x_1}\cdot x_2 + x_1\cdot \overline{x_2}$ 
	
	![[Pasted image 20250224105834.png]]

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 0   |
| 1     | 0     | 1   |
| 0     | 1     | 1   |
| 1     | 1     | 0   |
7. Сложение по модулю 2 с инверсией
	$y=\overline{x_1\oplus x_2}$ ИЛИ $y=\overline{x_1}\cdot \overline{x_2} + x_1\cdot x_2$ 

| $x_1$ | $x_2$ | $y$ |
| ----- | ----- | --- |
| 0     | 0     | 1   |
| 1     | 0     | 0   |
| 0     | 1     | 0   |
| 1     | 1     | 1   |


Основное понятие - понятие функциональной полноты булевой функции. 
*Опр.* Система булевых функций называется **функционально полной**, если на её основе можно получить любую булеву функцию, используя лишь операцию суперпозиций.
Набор функций "И", "ИЛИ", "НЕ" является функционально полной системой.
Набор функций "И-НЕ" тоже является функционально полной системой.
Набор функций "ИЛИ-НЕ" тоже является функционально полной системой.

Принцип суперпозиций понимается как подстановка одних булевых функций в качестве аргументов других булевых функций. 
$$ y_1 = x_2 + x_3$$
$$f = x_1 \cdot y = x_1 \cdot (x_1 + x_2) $$

## Основные законы булевой алгебры

1. Двойное отрицание - значение самой переменной. $$\overline{\overline{x}} = x$$
2. Коммутативность
3. Дистрибутивность
4. Ассоциативность
5. Распределительный закон
6.  $x + 0 = x$
	$x+ 1 = 1$
	$x \cdot 0 = 0$
	$x \cdot 1 = x$
	$x \cdot x = x$
	$x \cdot \overline{x} = 0$
	$x + \overline{x} = 0$
7. Законы Де-Моргана
	$\overline{x_1 \cdot x_2} = \overline{x_1} + \overline{x_2}$
	$\overline{x_1 + x_2} = \overline{x_1} \cdot \overline{x_2}$
	$x_1 \cdot x_2 = \overline{\overline{x_1} + \overline{x_2}}$
	$x_1 + x_2 = \overline{\overline{x_1} \cdot \overline{x_2}}$
8. Закон склеивания и поглощения
	$x_1\cdot(x_1+x_2) = x_1$
	$x_1 + x_1 \cdot x_2 = x_1$
	$x_1 + \overline{x_1}\cdot x_2 = x_1 + x_2$
	$x_1 \cdot (\overline{x_1} + x_2) = x_1 \cdot x_2$


С помощью таблиц истинности удобно описывать поведение логической схемы, а с помощью аналитического выражение - структуру. 

## Нормальная форма булевых функций

Возьмём произвольную функцию $f(x_1, x_2, x_3) = (x_1 + \overline{x_2})\cdot(\overline{x_1}+x_3) + x_2\cdot x_3$
В алгебре логики выделяют ряд форм, которые называются нормальными формами, т.е. подразумевается, что у функций может быть несколько аналитических представлений, но нормальная форма одна.
1. ДНФ. Сумма произведений
	Минтерм - конъюнктивный терм, который содержит все переменные функции. 1 - наименьший конъюнктивный терм.
	СДНФ -  Совершенная дизъюнктивная нормальная форма - ДНФ, состоящая только из минтермов. 
2. КНФ. Произведение сумм
	Макстерм - дизъюнктивный терм, который содержит все переменные функции.  0 - наименьший дизъюнктивный терм. 
	СКНФ -  Совершенная конъюнктивная нормальная форма - КНФ, состоящая только из макстермов.

СДНФ и СКНФ у булевой функции могут быть только одни. 

## Получение совершенных форм по таблице истинности

1. Задана функция $y = f(a,b,c)$ с помощью таблицы истинности

| a   | b   | c   | y   |
| --- | --- | --- | --- |
| 0   | 0   | 0   | 0   |
| 0   | 0   | 1   | 0   |
| 0   | 1   | 0   | 0   |
| 0   | 1   | 1   | 1   |
| 1   | 0   | 0   | 0   |
| 1   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   |
| 1   | 1   | 1   | 1   |
Как получить СДНФ:
1. Выбираются строки, где функция равна 1
2. Каждой такой строке соответствует терм, переменная входит без отрицания, если значение переменной равно 1; с отрицанием, если значение переменной равно 0.
3. Полученные термы записываются через "+"
$$y = \overline{a}\cdot b \cdot d + a \cdot b \cdot \overline{c} + a \cdot b \cdot c$$

Как получить СКНФ:
1. Выбираются строки, где функция равна 0
2. Каждой такой строке соответствует терм, переменная входит без отрицания, если значение переменной равно 0,с отрицанием, если значение переменной равно 0.
3. Полученные термы записываются через умножение. 
$$ y = (a+b+c)\cdot(a+b+\overline{c})\cdot(a+\overline{b}+c)\cdot(\overline{a}+b+c)\cdot(\overline{a}+\overline{b}+c)$$
Ну и соответственно можно обратно по форме построить схему....

В аналитическом выражении операции выполняются по приоритету: отрицание, умножение, сложение, сложение по модулю два.

# Лекция №2. 
*К предыдущей лекции, а то забыли.* Существуют два основных класса логических схем.

*Опр.* Логическая схема, которую можно полностью описать таблицами истинности  или булевыми выражениями, называется __комбинационной схемой__. (КС)
Особенность таких схем является: значение выходных сигналов полностью определяются значениями входных сигналов в текущий момент времени. 

*Опр.* __Последовательстные схемы__ или схемы с внутренней памятью - схемы, где значения выходных сигналов определяются не только текущими значениями входных сигналов, но и их значениями в предыдущие моменты времени. 

## Минимизация логических функций
Сложность логических функций, а так же сложность реализующей её логической схемы, прямопорциональны числу операций и числу переменных. (см пример выше) Поэтому при проектировании логических схем выполняют *минимизацию* логических функций.

*Опр*. Минимизацией логических функций называют нахождение наиболее простого её представления с минимальным количеством символов(операций и переменных). 

Рассмотрим два способа минимизации функций. 

### Преобразование аналитического выражения
$$y = \overline{a}bc + ab\overline{c} + abc = \overline{a}bc + ab(\overline{c}+c) = \overline{a}bc + ab = b\cdot(a+\overline{a}c) = b\cdot(a+c) = ab + bc$$

Построим схему по полученному выражению:
/тут две картинки должны быть/

Рассмотрим ещё один пример:
$$y = x_1\cdot x_2 + x_2\cdot x_3 + \overline{x_1}\cdot x_3$$
Представим $x_2\cdot x_3\cdot 1$ как $x_2\cdot x_3 (x_1 + \overline{x_1})$:
$$y = x_1\cdot x_2 + x_1\cdot x_2\cdot x_3 + \overline{x_1}\cdot x_2\cdot x_3 + \overline{x_1}\cdot x_3 = x_1\cdot x_2 (1+ x_3) + \overline{x_1}\cdot x_3(1+x_2) = x-1 \cdot x_2 + \overline{x_1} \cdot x_3$$

Почему это неудобно? Этот способ не является алгоритмическим, поэтому не очень понятно, когда стоит применять такой способ

### Карты Карно
А это уже алгоритмический способ, так что сидим радуемся жизни. 
Для расширения кругозора: карты Карно ещё называются диаграммами Вейче.

Карты Карно это графическое двухмерное представление таблицы истинности. Значения в карте Карно записываются как по горизонтали, так и по вертикали. Переменные функции делят пополам: если количество переменных чётно, то записывают пополам, если нечётно, то по горизонтали или вертикали, то где-то на одну больше. 
Порядок размещения различных комбинаций значений переменных выбирается в коде Грея, т.е. наборы значений соседних клеток различаются одним разрядом. 

#### Получение кода Грея


#### Непосредственно карты Карно

Таблица исходной функции:

| a   | b   | f   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   |

Составим карту Карно с переменной b по горизонтали и переменной а по вертикали:

| ...   | 0   | 1   |
| ----- | --- | --- |
| __0__ | 0   | 0   |
| __1__ | 0   | 1   |

Составим карту Карно для 3 переменных:

| ...   | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| __0__ |     |     |     |     |
| __1__ |     |     |     |     |

Аналогично для 4 и более переменных 

## Получение минимальной ДНФ по картам Карно

1. Заполняются ячейки карты Карно по таблице истинности для функции.
2. На карте Карно выделяются прямоугольные контуры по следующим правилам:
	1. Контуры могут содержать только 1.
	2. Количество клеток внутри контура может быть равно только степени 2. ($2^0$, $2^1$ и др.... т.е. в контуре может быть 1, 2, 4 и тд клеток)
	3. Контуры могут пересекаться.
	4. Сами контуры, т.е. их размер, должны быть как можно больше. 
	5. Количество контуров должно быть как можно меньше.
	6. Следует учитывать, что верхняя строка и нижняя строка карты Карно являются соседними, а так же левый и правый столбцы тоже являются соседними. 
3. Получение МДНФ: каждому выделенному контуру соответствуют терм ака конъюнкция переменных. Причём в терм входят только те переменные, которые не меняют своего значения в пределах контура. Переменная входит без отрицания, если она равна 1 в пределах контура, или с отрицанием, если она равна 0 в пределах контура. 
4. Полученные термы объединяются в функции дизъюнкции. 

Пример на нашем любимом примере)))))))))))).
Функция для минимизации: $y = \overline{a}bc + ab\overline{c} + abc$

Карта Карно(a по вертикали и bc по горизонтали):

| ...   | 00  | 01  | 11            | 10      |
| ----- | --- | --- | ------------- | ------- |
| __0__ |     |     | 1(1 к.)       |         |
| __1__ |     |     | 1(1 к.)(2 к.) | 1(2 к.) |

Первый контур: $bc$ 
Второй контур: $ab$ 

Объединяем: $y = ab + bc$
Получили ту же самую форму, которую получили преобразованием.

#### Ыщо примеры на выделение контуров

##### Пример №1
ab по вертикали и cd по горизонтали

| ...    | 00      | 01   | 11   | 10   |
| ------ | ------- | ---- | ---- | ---- |
| __00__ | 1(2)    |      | 1(3) | 1(3) |
| __01__ | 1(2)    |      | 1(3) | 1(3) |
| __11__ | 1(1)(2) | 1(1) |      |      |
| __10__ | 1(2)    |      |      |      |
(Колво клеток тока по степеням двойки!!!!!!)

Первый контур: $\overline{c}\overline{d}$
Второй контур: $ab\overline{c}$
Третий контур: $\overline{a}c$

МДНФ: $f = ab\overline{c}+\overline{c}\overline{d}+\overline{a}c$

##### Пример №2
ab по вертикали и cd по горизонтали

| ...    | 00   | 01  | 11   | 10   |
| ------ | ---- | --- | ---- | ---- |
| __00__ |      |     | 1(2) |      |
| __01__ | 1(1) |     |      | 1(1) |
| __11__ | 1(1) |     |      | 1(1) |
| __10__ |      |     | 1(2) |      |
(Препод дальтоник, рисуем контуры овальчиками)

Первый контур: $b\overline{d}$
Второй контур: $\overline{b}cd$

МДНФ: $f = b\overline{d}+ \overline{b}cd$

##### Пример №3
ab по вертикали и cd по горизонтали

| ...    | 00  | 01  | 11  | 10  |
| ------ | --- | --- | --- | --- |
| __00__ | 1   |     |     | 1   |
| __01__ |     |     |     |     |
| __11__ |     |     |     |     |
| __10__ | 1   |     |     | 1   |
Ставьте лайк если тоже нашли один контур

МДНФ: $f = \overline{b}\overline{d}$

### Синтез полного одноразрядного сумматора
В базисе "И", "ИЛИ", "НЕ"
/картинка/
$S = f(A, B, P_0)$
$P_1 = \phi(A,B,P_0)$
??????

| $P_0$ | A   | B   | S   | $P_1$ |
| ----- | --- | --- | --- | ----- |
| 0     | 0   | 0   | 0   | 0     |
| 0     | 0   | 1   | 1   | 0     |
| 0     | 1   | 0   | 1   | 0     |
| 0     | 1   | 1   | 0   | 1     |
| 1     | 0   | 0   | 1   | 0     |
| 1     | 0   | 1   | 0   | 1     |
| 1     | 1   | 0   | 0   | 1     |
| 1     | 1   | 1   | 1   | 1     |

Карта Карно:

| ...   | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| __0__ |     | 1   |     | 1   |
| __1__ | 1   |     | 1   |     |

А как минимизировать..... никак.

$S = \overline{P_0}\cdot \overline{A}B + P_0\cdot \overline{A}\overline{B} + P_2\cdot A\cdot B + \overline{P_0}A\overline{B}$
$P_1 = A\cdot B + P_0 \cdot B + P_0 \cdot A$

Схема:
//картинка//

Требование с Госта: входы слева, выходы справа, линии только горизонтальные и вертикальные


# Лекция №3
Полный одноразрядный сумматор: надо сложить два одноразрядных числа по модулю два. Учитывается перенос остатка.
Схема:
![[Pasted image 20250224103421.png]]

$$S = \overline{A}\cdot \overline{B}\cdot P_0 + \overline{A} \cdot B \cdot \overline{P_0} + A\cdot B \cdot P_0 + A \cdot \overline{B}\cdot \overline{P_0} = P_0(\overline{A}\cdot \overline{B}+A\cdot B)+\overline{P_0}(\overline{A}\cdot B + A \cdot \overline{B})$$
$$S=P_0(\overline{A\oplus B})+\overline{P}(A\oplus B) = P_0 \oplus(A \oplus B)$$
Для $P_1$:
$$P_1 = A\cdot B + P_0 \cdot A + P_0 \cdot B=A\cdot B + P_0(A+B) = A\cdot B + P_0 (A\oplus B)$$
## Задача №1
Синтезировать схему в базисе "И", "ИЛИ", "НЕ" по функции, заданной картой Карно

| .... | 00  | 01  | 11  | 10  |
| ---- | --- | --- | --- | --- |
| 00   | 1   | 1   | 1   | 1   |
| 01   | 1   | 1   |     |     |
| 11   | 1   |     | 1   |     |
| 10   | 1   | 1   |     | 1   |

Контуры:
![[Pasted image 20250224103050.png]]

ДНС:
$$f=\overline{a}\cdot\overline{b} + \overline{b} \cdot \overline{d} + \overline{a}\cdot \overline{c} + \overline{c} \cdot \overline{d} + \overline{b} \cdot \overline{c} + a\cdot b \cdot c \cdot d $$

Схема:
/картинка/


## Получение МКНФ по картам Карно
Правило:
1. Выделяют контуры с нулями по тем же правилам, что и для ДНФ.
2. По этим контурам строится мднф для инверсного значения функции, т.е. $\overline{f}$
3. Берём инверсию слева и справа получаем мкнф для самой функции $f$.

Пример:

| .... | 00  | 01  | 11  | 10  |
| ---- | --- | --- | --- | --- |
| 00   | 1   | 1   | 0   | 1   |
| 01   | 0   | 0   | 0   | 0   |
| 11   | 0   | 0   | 0   | 1   |
| 10   | 1   | 1   | 0   | 1   |

Контуры:
![[Pasted image 20250224104534.png]]

Запишем МНДФ:
$$\overline{f} = c\cdot d + \overline{a} \cdot b + b \cdot \overline{c}$$
$$ \overline{\overline{f}} = \overline{c\cdot d + \overline{a} \cdot b + b \cdot \overline{c}}$$
$$ f = \overline{c \cdot d}+ $$

## Неопределённые условия
При проектировании логических схем возможна некоторая комбинация на входе, которая не может появиться или запрещена. В таблице истинности такая строка отсутствует, а в карте Карно ставят символ, отличный от "0" или "1".
При выделении контуров эту клетку можно считать как за "0", так и за "1". Интерпретируем в сторону нашей выходы, т.е. в сторону минимизации количества контуров.

Пример:

| .... | 00  | 01  | 11  | 10  |
| ---- | --- | --- | --- | --- |
| 00   | 0   | -   | 0   | 1   |
| 01   | -   | 1   | 0   | 1   |
| 11   | 0   | 0   | -   | 1   |
| 10   | 0   | 0   | 0   | -   |

Контуры:

![[Pasted image 20250224105550.png]]

МДНФ:
$$f = c\overline{d} +\overline{a}b\overline{c}$$


## Реализация функции на базисе И-НЕ, ИЛИ-НЕ

мумуму мимимими напишите пожалуйста



## Триггерные схемы

Относится к классу последовательностных схем. 
*Опр*. Триггер - устройство с двумя устойчивыми состояниями. 

## Обобщённая структурная схема триггера
![[Pasted image 20250224112925.png]]
ЗЯ - Запоминающая ячейка, СУ - Схема управления, $x_1, x_2 ... x_n$ - информационные сигналы триггера, $c_1, c_2 ... c_n$ - входы синхронизации. 
У триггера всегда два выхода.
Состояние триггера определяется значениями его выходов. 
	Состояние "0": $Q= 0$ , $\overline{Q} = 1$
	Состояние "1": $Q= 1$ , $\overline{Q} = 0$
Cхема управления преобразует входные сигналы и сигналы обратной связи в сигналы S' и R'. S' устанавливает ЗЯ в "1", R' устанавливает в состояние "0".
Запоминающая ячейка сама по себе представляет простейший триггер.

## Классификация триггеров

По функциональному признаку:
1. RS
2. JK
3. D
4. DV(E)
5. T
Возможны комбинированные триггеры.

По способу записи информации:
1. Асинхронные
2. Синхронные

По числу входов синхронизации:
1. Однотактные
2. Многотактные

По организации синхронизирующего входа:
1. Статическое управление записью (происходит по уровню сигнала)
2. Динамическое управление записью (по фронту сигнала, по переднему или по заднему)

По способу передачи входной информации на выход:
1. Одноступенчатые
2. Двухступенчатые

## Основные параметры триггеров

### Схемотехнические
1. Коэффициент объединение по входам (макс. число входов)
2. Коэффициент разветвтления по выходу
3. Напряжение допустимое по мете
4. Входные и выходные напряжение и токи логических "0" и "1"
5. Потребляемая мощность

### Динамические параметры
1. Минимальная длительность входного импульса
	$$t_и = \sum_{i=1}^{i = m}t^* \cdot i$$
	$m$ - колво лог. элементов в цепи от входа(информационного или синхросигнала) до входа логического элемента, на котором замыкается кольцо обратной связи.
2. Разрешающее время триггера или синхросигнала
	Минимально допустимый временной интервал между двумя последовательными импульсами минимальной длительности. 

# Лекция № 4
 Триггерры применяются в счётчиках, регистрах, а так же в памяти если нужно хранить значение нескольких битах, в накапливающих сумматоров, генераторов одиночных импульсов, формирователей сигналов. Используются там где нужно выполнять функции хранения информации.
 
 ## Логическое описание работы триггеров
 Правило Функционирования триггеров могут быть заданы с помощью:
	 Словестное описание
	 Лог функций
	 Таблицы переходов - не путать с таблицой истинности
	 Графов - в котором вершина сотвествует  внутренее состояние тригера, а ребрам управляющий сигнал.
	 В форме микропрограммного автомата
При описание работы триггерра рассматривают два соседних моментов дискретного времени. t_n+2, t_n+1, t_n

Для асинхронных триггероов момент времени t_n+1, когда под действием входных сигналов и взависимости внутренного состояния момента t_n, Триггер переходит в последующее состояние.
Для синхронного сигнала tn и t_n+1 время до и после прихода синхро сигнала соотвествено.

Схемки .......

## Асинхронный RS-триггер (простейший триггер)
С входами R установки в ноль и S установки в 1. используется как запоминающаю ячейку. 

| Время t_n | Время t_n | Время t_n | Время t_n+1 |                                                |
| --------- | --------- | --------- | ----------- | ---------------------------------------------- |
| $R_n$     | $S_n$     | $Q_n$     | $Q_n$       |                                                |
| 0         | 0         | 0         | 0           | $R_n$=$S_n$=0 Режим хранения                   |
| 0         | 0         | 1         | 1           | $R_n$=$S_n$=0, РЕЖИМ ХРАНЕНИЯ $Q_{n+1} = $Q_n$ |
| 0         | 1         | 0         | 1           | Режим переключения в 1                         |
| 0         | 1         | 1         | 1           | Режим переключения 1                           |
| 1         | 0         | 0         | 0           | Режим сброса или переключения в 0              |
| 1         | 0         | 1         | 0           | Режим сброса или переключения в 0              |
| 1         | 1         | 0         | x           | Запрещённая комбинация                         |
| 1         | 1         | 1         | x           | Запрещённые комбинации                         |
$Q_{n+1}=f(R_n,S_n,Q_n)-?$
$Q_{n+1}=\varphi(R_n,S_n,Q_n)-?$

Через карты Карно получим выражения для триггерра RS
$Q_{n+1}=S_n+\bar{R_n}Q_n$(1)
$\bar Q_{n+1}=R_n+\bar{S_n}\bar Q_n$(2)

Для реализации в базисе "и или не" преобразуем формулы 1,2
Из (1): $$\bar Q_{n+1}=\overline{S_n+\bar R_nQ_n}=\overline{S_n+\overline{R_n\bar Q_n}}$$
Из (2): $$Q_{n+1}=\overline{R_n+\overline{S_n+Q_n}}$$
Cхема триггера

Приято рисовать

Упрощённый вариант

Анализируем работу схемы
Много раз нарисовать ячейку с разными состояниями
	1. $R=S=0$ 
		1. $Q=0;\bar Q=1$ (единица на выходе устанавливает 1, если все сигналы нулю равны) Ноль с ЛС1  выхода попадает на вход ЛС2 потверждает 1 состояния входа $\bar Q = 1$ так как  $S=0$. С другой стороны выход ЛС2 потверждает выход $Q=0$, так как $R=0$.
		2.$Q=1;\bar Q = 0$ Единица с ЛС1  выхода попадает на вход ЛС2 потверждает состояния входа $\bar Q =01$ так как  $S=0$. С другой стороны выход ЛС2 потверждает выход $Q=1$, так как $R=0$.
	2. $R=1;S=0$
		1. $Q=0;\bar Q=1$. $R=1$ даже действуя многократно будет, только подтверждать нулевое сотояние выхода ЛС1 и будет подтверждать состояния выхода ЛС2, так как $S=0$.
		2. $Q=1;\bar Q = 0$ переключит состояние в сотояние выхода ЛС1 1->0  и переключит состояния выхода ЛС2 в 1, так как $S=0$, выход ЛС2 потвердит состояние $Q=0$.
	3. $R=0;S=1$
		1. $Q=0;\bar Q=1$. $S= 0$ переключит состояние в сотояние выхода ЛС2 1->0  и переключит состояния выхода ЛС1 в 1, так как $R=0$, выход ЛС1 потвердит состояние $Q=0$..
		2. $Q=1;\bar Q = 0$  Ничего не изменится система не поменятеся.
Отметим Случай 2.1 И 3.2 триггер сохраняет своё прежнее состояние при многократном действие сигнала R или S - называется свойством блокировки, которое и делает RS-триггер запоминающей ячейкой.
	 $R=S=1$ Схема перестаёт быть триггером и считается двумя отдельными ЛC(Kjubxtcrfz c[tvf]). $Q=\bar Q -???$.  Что будет если мы "одновременно снимем". Мы не знаем в каком состояние окажется триггер. Такая же проблема во всех компьютерах при включение его неизвестно в каком состояние будет триггер. Поэтому компы после включения делают инициализацию.
Чтобы переключить триггер в базисе "или не" нужно подать единичные сигналы. Такой триггер называется триггер с прямыми входами.В таком триггере активные уровни сигнал будут единицы.
Если реализовать в бизисе "и не" то будет триггер с инверсными входами. В таком триггере активные уровни сигнал будут нули.
(1): $$Q_{n+1}=\overline{\overline{S_n+\bar R_n*Q_n}}=\overline{\bar S_n *\overline{\bar R_n * Q_n}}$$(2): $$Q_{n+1}=\overline{\overline{R_n+\bar S_n*\bar Q_n}}=\overline{\bar R_n *\overline{\bar S_n * \bar Q_n}}$$

| $\bar S$ | $\bar R$ |            |
| -------- | -------- | ---------- |
| 1        | 1        | хранение   |
| 0        | 1        | уст 1      |
| 1        | 0        | уст 0      |
| 0        | 0        | запрещенна |

Проиллюстрируем работу триггера( временная диаграмма)

# Лекция №5. Состязание(гонки) в асинхронных схемах
Логические функции описывают схему идеализированно, так как они не учитывают задержки в элементах. Наличие задержек в элементах приводит к появлению "гонок" в сигналах. 
Рассмотрим пример.
Есть вот такая схема, по которой мы всегда будем получать на выходе единицу. 
![[Pasted image 20250310101636.png]]

Построим временные диаграммы с учётом задержек на логических элементах:
![[Pasted image 20250310101843.png]]

Отсюда видно, что во время переключения возникает *ложный сигнал* или *помеха*. 
Причины помех:
1. Разное количество логических элементов от входа сигнала до выхода
2. Разные задержки на разных логических элементах

*Опр*. Возможность появления помехи в результате гонок сигналов называют **статическим риском сбоя**.
Для исключения таких сбоев вводят **стробирование**. 

*Опр*. Под **стробированием** понимают выделение из информационного сигнала части, свободной от ложных сигналов. 

*Опр*. Процесс стробирования периодическими сигналами называют **синхронизацией**. 
*Опр*. **Такт** - период следования синхросигнала. 

Синхронизация это частный случай стробирования.

Как правило, всякая комбинационная цепь заканчивается триггером, поэтому стробирование вводят на входах триггерных схем. 

*Опр*. Триггеры, информационные входные сигналы которых стробируются специальными периодическими  импульсами, называются **синхронными триггерами**.

На ряду с защитой от "состязаний" введение синхронизации создаёт условия для одновременного изменения состояния многих триггеров, так называемая *синхронная работа*.

## Синхронные триггеры

Синхронные триггеры имеют один или несколько входов синхронизации. Сигнал синхронизации разрешает приём в триггер сигналов с информационных входов. 
Входы синхронизации обозначают буквой *С*. 
При *С* = 1 вход разрешён, при *С* = 0 вход запрещён. 
Если вход инверсный, то наоборот. 

### Синхронный RS триггер
Как у асинхронного RS триггера есть входы S и R, а ещё есть синхронизирующий вход С. 
Таблица переходов для синхронного RS триггера:

| $C_n$ | $R_n$ | $S_n$ | $Q_n$ | $Q_{n+1}$ |
| ----- | ----- | ----- | ----- | --------- |
| 0     | 0     | 0     | 0     | 0         |
| 0     | 0     | 0     | 1     | 1         |
| 0     | 0     | 1     | 0     | 0         |
| 0     | 0     | 1     | 1     | 1         |
| 0     | 1     | 0     | 0     | 0         |
| 0     | 1     | 0     | 1     | 1         |
| 0     | 1     | 1     | 0     | 0         |
| 0     | 1     | 1     | 1     | 1         |
| 1     | 0     | 0     | 0     | 0         |
| 1     | 0     | 0     | 1     | 1         |
| 1     | 0     | 1     | 0     | 1         |
| 1     | 0     | 1     | 1     | 1         |
| 1     | 1     | 0     | 0     | 0         |
| 1     | 1     | 0     | 1     | 0         |
| 1     | 1     | 1     | 0     | x         |
| 1     | 1     | 1     | 1     | x         |

Целевая функция: $Q_{n+1} = f(C_n, S_n, R_n, Q_n)$ - ?
При *С* = 0, $Q_{n+1} = Q_n$
При $C = 1$, 
Первые две строки - режим хранения
Установка в 1
Установка в 0
Запрещённые комбинации

Карта Карно для функции, по горизонтали $C_n, R_n$:

| --  | 00  | 01  | 11  | 10  |
| --- | --- | --- | --- | --- |
| 00  |     |     |     |     |
| 01  | 1   | 1   |     | 1   |
| 11  | 1   | 1   | x   | 1   |
| 10  |     |     | x   | 1   |

$$Q_{n+1} = \overline{C_n}\cdot Q_n+ C_n\cdot S_n + \overline{R_n}\cdot Q_n$$
Но это неудобно, поэтому преобразуем, чтобы было удобнее реализовать в базисе И-НЕ:
$$ Q_{n+1} = Q_n (\overline{C_n} + \overline{R_n}) + C_n \cdot S_n = C_n\cdot S_n + \overline{C_n \cdot R_n}\cdot Q_n$$ (1)

Аналогично, но самостоятельно, получаем $\overline{Q_{n+1}} = C_n\cdot R_n + \overline{C_n \cdot S_n} \cdot \overline{Q_n}$ (2).

Возьмём  двойную инверсию (1): $Q_{n+1} = \overline{\overline{C_n \cdot S_n}\cdot \overline{\overline{C_n \cdot R_n}\cdot Q_n}}$
(2): $\overline{Q_{n+1}} = \overline{\overline{C_n \cdot R_n}\cdot \overline{\overline{C_n \cdot S_n}\cdot \overline{Q_n}}}$

Из этих двух выражений получим схему:
![[Pasted image 20250310104910.png]]

Условное изображение триггера:
![[photo_2025-03-10_10-48-43.jpg]]


Проиллюстрируем работу триггера с помощью временных диаграмм и оценим работу триггера:
![[Pasted image 20250310110722.png]]

$$t_и \ge3 t^* _{зд. р. ср.}$$
$$t_р \ge 4 t^* _{зд. р. ср.}$$
$$t_{max} = \frac{1}{t_р} = \frac{1}{4 t^* _{зд. р. ср.}}$$

Раз реализовали в И-НЕ, реализуем в ИЛИ-НЕ:
![[Pasted image 20250310110816.png]]
Получили триггер с инверсными входами. 

### Синхронный D триггер
**Асинхронных D триггеров не бывает**
Таблица переходов:

| $C_n$ | $D_n$ | $Q_n$ | $Q_{n+1}$ | $S^*$ | $R^*$ |
| ----- | ----- | ----- | --------- | ----- | ----- |
| 0     | 0     | 0     | 0         | 1     | x     |
| 0     | 0     | 1     | 1         | x     | 1     |
| 0     | 1     | 0     | 0         | 1     | x     |
| 0     | 1     | 1     | 1         | x     | 1     |
| 1     | 0     | 0     | 0         | 1     | x     |
| 1     | 0     | 1     | 0         | 1     | 0     |
| 1     | 1     | 0     | 1         | 0     | 1     |
| 1     | 1     | 1     | 1         | x     | 1     |

При $C=0$, $Q_{n+1} = Q_n$

 Карта Карно:

| ---   | 00  | 01  | 11  | 10  |
| ----- | --- | --- | --- | --- |
| **0** |     |     | 1   |     |
| **1** | 1   | 1   | 1   |     |
$$Q_{n+1} = \overline{C_n}\cdot Q_n + C_n \cdot D_n$$

При $C_n = 1$ получаем просто повторитель сигнала. $Q_{n+1} = D_n$, который не обладает памятью.
Будем строить схему ну основе запоминающей ячейки в базисе И-НЕ:


| $Q_n \rightarrow Q_{n+1}$ | $S^*$ | $R^*$ |
| ------------------------- | ----- | ----- |
| 0 -> 0                    | 1     | x     |
| 0 -> 1                    | 0     | 1     |
| 1 -> 0                    | 1     | 0     |
| 1 -> 1                    | x     | 1     |
=>
$S^* = f(C_n, D_n)$ и $R^* = f(C_n, D_n)$

Карта Карно для $S^*$:

| $Q_n$ \\ $C_n, D_n$ | 00  | 01  | 11  | 10  |
| ------------------- | --- | --- | --- | --- |
| **0**               | 1   | 1   |     | 1   |
| **1**               | x   | x   | x   | 1   |

$$S^* = \overline{C_n}+\overline{D_n} = \overline{C_n \cdot D_n}$$
Карта Карно для $R^*$:

| $Q_n$ \\ $C_n, D_n$ | 00  | 01  | 11  | 10  |
| ------------------- | --- | --- | --- | --- |
| **0**               | x   | x   | 1   | x   |
| **1**               | 1   | 1   | 1   |     |
$$R^* = \overline{C_n} + D_n = \overline{\overline{D_n}\cdot C_n}$$
Чтобы обойтись без инвертера преобразуем ф-цию.
$$R^* = \overline{C_n} + D_n = \overline{C_n}+D_n(C_n + \overline{C_n}) = D_n \cdot \overline{C_n} + \overline{C_n} = D_n\cdot C_n + \overline{C_n}(D_n+1) = D_n \cdot C_n + \overline{C_n}$$
$$R^* = \overline{S^*} + \overline{C_n} = \overline{S^* \cdot C_n}$$


Схема:
![[Pasted image 20250310113855.png]]
# Лекция №6
	На следующей паре РК, всё что было в лекции, может быть на РК . Ыгыгыгы)))
	Тема: Синтез комбинационных схем.
	Теории в следующий раз не будет.

## Асинхронный T-триггер
Счётный триггер, так как он умный и умеет считать до двух.
Асинхронный Т триггер функционирует в соответствии со следующей таблице. Имеет один счётный вход, текущее состояние зависит от предыдущего.

| $T_n$ | $Q_n$ | $Q_{n+1}$ | $R'$ | $S'$ |
| ----- | ----- | --------- | ---- | ---- |
| 0     | 0     | 0         | х    | 0    |
| 0     | 1     | 1         | 0    | х    |
| 1     | 0     | 1         | 0    | 1    |
| 1     | 1     | 0         | 1    | 0    |
$Q_{n+1} = f(T_n, Q_n)$
Каждым входным сигналом триггер переключается в следующее состояние.
Строим ДНС:
$Q_{n+1} = \overline{T_n}\cdot Q_n + T_n \cdot \overline{Q_n} = T_n \oplus Q_n$
Нет свойства памяти => строим счётный триггер на основе запоминающей ячейки. Выберем запоминающую ячейку с прямыми входами, тогда сигналы, обеспечивающие переходы, будут следующими:
$R' =T_n \cdot Q_n$ и $S' = T_n \cdot \overline{Q_n}$
Для реализации в базисе И-НЕ возьмём инверсию справа и слева:
$\overline{R'} =\overline{T_n \cdot Q_n}$ и $\overline{S'} = \overline{T_n \cdot \overline{Q_n}}$

Получим следующую схему:
![[Pasted image 20250317102716.png]]

Построим временные диаграммы, чтобы оценить работу схемы:


Когда приходит подтверждение единицы по обратной связи, надо снимать сигнал. Если длительность входного сигнала дольше, чем переходные процессы в триггере, то там возникают колебания и получается генератор, т.е. при действии входного сигнала T триггер многократно переключается между 1 и 0 многократно
$t_и = 2 t^*_{зд.р.ср}$. Генерация возникает, если длина импульса будет больше $2 t^*_{зд.р.ср}$, соответственно длина импульса Т должна быть строго $2 t^*_{зд.р.ср}$, меньше нельзя, так как не успеют сработать элементы 3 и 4. Жёстко стабилизировать время импульса практически невозможно. При изменении внешних условий такая схема будет работать неустойчиво. Поэтому такую схему не используют хд

## Синхронные триггеры с двухступенчатым упоминанием информации и со статическим управлением....

Для построения триггеров типа T- и JK- необходимо, чтобы изменения выходных сигналов было с задержкой, равной длительности входного сигнала. Аналогичная задача возникает, когда необходимо передавать информацию с выхода на вход другого/последующего триггера с помощью одного и того же синхросигнала, например, при построении регистров и счётчиков. 
Для решения этих проблем счётные и JK-триггеры строятся как двухступенчатые или триггеры с динамическим управлением. Пока будем говорить про двухступенчатые с динамическим управлением записью.

В двухступенчатых триггерах имеются две ступени запоминания информации.
1. Основной триггер
2. Вспомогательный триггер
В англоязычной литературе это MS-триггеры. (Master-Slave)

С = 1 - информация записывается в первую ступень, во вторую передача информации запрещена
С = 0 - информация переписывается из первой ступени во вторую, приём информации в первую ступень запрещена. 

Управляющая связь между основным и вспомогательным триггерами может осуществляться следующими способами:
1. С инвертером синхросигнала (запрещающим инвертером)
2. С запрещающими связями
3. С разнополярным управлением
И куча всего разного

### Двуступенчатый RS триггер с запрещающим инвертером

![[Pasted image 20250317112359.png]]

1,2,3,4 - первая ступень, 5,6,7,8 - вторая ступень

К ячейкам 3,4,7,8 подключаем входы  $S_a$ и $R_a$.(см RS триггер)
Эти входы будут инверсными

Динамические параметры данной схемы:
Мин время синхроимпульса: $t_и = 3t*_{зд.р.ср.}$
Разрешающее время синхросигнала: $t = 7t^*$

Если к логическим элементов добавить по сходу, т.е. соединив $\overline{Q}$ со входом элемента 2, а $Q$ с 1, то получится JK триггер. S станет J, а R станет K.

## Синхронные двуступенчатые триггеры с запрещающими связями

### Синхронный двуступенчатый JK триггер

В JK триггере вход J соответствует входу S в RS триггера(установка в 1), K - R(установка в 0).
Отличие от JK триггера от RS триггера заключается в том, что у него нет запрещающей комбинации на входе

S=R=C=1 -> запрещающий
J=K=C=1 -> переключение

Всё остальное как у RS

Нарисуем схему в базисе И-НЕ:
(у второй ступени два синхровхода)
![[Pasted image 20250317112659.png]]

Условная схема:
![[photo_2025-03-17_11-29-08.jpg]]
При С=1 и любом сочетании J и К (кроме J=K=0), состояние нуля будет либо на элементе 1, либо на элементе 2. Этот 0 переключит запоминающую ячейку первой ступени в соответствующее состояние(1 в 1, 2 в 0). Одновременно этот 0 попадает на 5 и 6, запрещая запись на вторую ступень. 
При С=0 на выходах логических элементов 1 и 2 единички, поэтому единица поступает на 5 и 6, разрешая запись с первой ступени на вторую.

Динамические параметры те же самые.

JK триггер называют универсальным триггером, так как его можно использовать в качестве RS, D и T триггера. 
Если входы J и K соединить через инвертер, то будет D триггер
Если J и K соединить и подавать единицу, то при каждом синхроимпульсе будет переключаться в следующее состояние, вход С станет входом Т, получится асинхронный счётный триггер.
Если объединить входы J и K, то они образуют синхронный счёт вход, получится синхронный счётный триггер. 